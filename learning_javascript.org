#+TITLE: Learning JavaScript
#+LANGUAGE: EN
#+AUTHOR: Yang Jie
#+EMAIL: outstanding.yang@gmail.com
#+DESCRIPTION: My notes on reading "JavaScript - The Definitive Guide 6th Edition"

JavaScript is the programming language of the Web. JavaScript is part of triad
of technologies that all Web developers must learn: *HTML* to specify the
content of web pages, *CSS* to specify the presentation of web pages, and
*JavaScript* to specify the behavior of web pages.

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:
Main structure of the book.
** Core JavaScript
   :PROPERTIES:
   :CUSTOM_ID: coreJavascript
   :END:
This is the lowest level of Java-Script including Lexical Structure, Types,
Values, Variables, Expressions and Operators, Statements, Objects, Arrays,
Functions, Classes and Modules, Pattern Matching with Regular Expressions,
Java-Script Subsets and Extensions.operation
** Client-Side JavaScript
   :PROPERTIES:
   :CUSTOM_ID: clientSideJavascript
   :END:
Client-Side JavaScript does not exhibit the nonlinear cross-reference problem
nearly to the extent that the core language does, and it is possible to learn
how to use JavaScript in web browsers in a fairly linear sequence.
* Getting Started
  :PROPERTIES:
  :CUSTOM_ID: gettingStarted
  :END:
** Lexical Structure
   :PROPERTIES:
   :CUSTOM_ID: lexicalStructure
   :END:
*** Character Set
    :PROPERTIES:
    :CUSTOM_ID: characterSet
    :END:
JavaScript programs are written using the Unicode character set.

JavaScript is a case-sensitive language, but HTML is not case-sensitive
(although XHTML is). Many client-side JavaScript objects and properties have the
same names as the HTML tags and attributes. Please be care!

JavaScript ignores spaces that appear between tokens in programs. Because you
can use spaces and newlines freely in your programs, you can format and indent
your programs in a neat and consistent way.

JavaScript defines special sequences of six ASCII character to represent any
16-bit Unicode codepoint. Unicode escapes begin with the characters \u and are
followed by exactly four hexadecimal digits. They may appear in JavaScript
string literals, and in identifiers (but not in language keywords). Also they
may appear in comments, but not interpreted as Unicode.
*** Comments
    :PROPERTIES:
    :CUSTOM_ID: comments
    :END:
Two styles of comments:
1. Any text between a // and the end of a line.
2. Any text between the characters /* and */, these comments may span multiple
   lines but may not be nested.
*** Literals
    :PROPERTIES:
    :CUSTOM_ID: literals
    :END:
A literal is a data value that appears directly in a program.
*** Identifiers and Reserved Words
    :PROPERTIES:
    :CUSTOM_ID: identifiers
    :END:
A JavaScript identifier must begin with a letter, an underscore, or a dollar
sign. Subsequent characters can be letters, digits, underscores, or dolor sign.
Digits are /not/ allowed as the first character.

JavaScript reserves a number of identifiers as the keywords of the language
itself. They are not allowed as variable, function, or parameter names.
*** Optional Semicolons
    :PROPERTIES:
    :CUSTOM_ID: optionSemicolons
    :END:
JavaScript uses the semicolon to separate statements from each other. In
JavaScript, you can usually omit the semicolon between two statements if those
statements are written on separate lines. You should always use semicolons to
explicitly mark the ends of statements, even where they are not required.

There are two exceptions to the general rule that JavaScript interprets line
breaks as semicolons when it cannot parse the second line as a continuation of
the statement on the first line.
1. return, break, and continue: You must not insert a line break between return,
   break, or continue and the expression that follows the keyword.
2. ++ and -- operators: as postfix operator, they must appear on the same line
   as the expression they apply to.
** Types, Values, and Variables
   :PROPERTIES:
   :CUSTOM_ID: typesValuesVariables
   :END:
Computer programs work by manipulating /values/, such as the number 3.14 or the
text "hello world". The kinds of values that can be represented and manipulated
in a programming language is the set of /types/ it supports. When a program
needs to retain a value for future use, it assigns the value to a /variable/.

JavaScript types can be divided into two categories:
- Primitive types :: numbers, strings, booleans, null, and undefined
- Object types :: Not primitive types are objects types
And types with methods and types without. Also, *mutable* and *immutable* types.

JavaScript object is an unordered collection of named values. The language
defines a special kind of object - /array/ that represents an ordered collection
of numbered values. Another special kind of object is a /function/ which has
executable code associated with it. The most important thing about functions in
JavaScript is that they are true values and JavaScript programs can treat them
like regular objects.

*Functions* that are written to be used (with the *new* operator) to initialize
a newly created object are known as /constructors/. Each constructor defines a
class of objects - the set of objects initialized by that constructor. *Classes*
can be thought of as subtypes of the object type. In addition to the *Array* and
*Function* classes, core JavaScript defines three other useful classes. The
*Date* class represents dates, the *RegExp* class represents regular expressions
and the *Error* class represents syntax and run-time errors. You can define your
own classes of objects by defining appropriate constructor functions.

The JavaScript interpreter performs /automatic garbage collection/ for memory
management.
JavaScript is an object-oriented language. It means that rather than having
globally defined functions to operate on values of various types, the types
themselves define /methods/ for working with values. Only JavaScript objects
have methods. But numbers, strings, boolean values behave as if they had method.
In JavaScript, /null/ and /undefined/ are the only values that methods cannot be
invoked on.
JavaScript variables are /untyped/. Variables are declared with the *var*
keyword. JavaScript uses /lexical scoping/.
*** Numbers
    :PROPERTIES:
    :CUSTOM_ID: numbers
    :END:
All numbers in JavaScript are represented as floating-point values. When a
number appears directly in a JavaScript program, it's called a /numeric literal/
. A minus sign makes number negative, but - is the unary negation operator and
is not part of the numeric literal syntax.
**** Integer Literals
base-10, base-16, and base-8 integer literals. A hexadecimal literal begins with
"0x" or "0X", followed by a string of hexadecimal digits. Although ECMAScript
standard does not support hexadecimal literals, some implementations of
JavaScript allow you to specify integer literals in octal. In the strict mode of
ECMAScript 5, octal literals are explicitly forbidden.
**** Floating-Point Literals
syntax: [digits][.digits][(E|e)[(+|-)]digits]
**** Arithmetic in JavaScript
JavaScript programs work with numbers using the arithmetic operators that the
language provides. In addition to basic arithmetic operators, JavaScript
supports more complex mathematical operations through a set of functions and
constants defined as properties of the *Math* object.

Arithmetic in JavaScript does not raise errors in cases of overflow, underflow,
or division by zero.
- Overflow :: when the result of a numeric operation is larger than the largest
              representable number, JavaScript prints as *Infinity*; contrastly,
              prints as *-Infinity*
- Underflow :: when the result of a numeric operation is closer to zero than the
               smallest representable number, JavaScript returns 0; If underflow
               occurs from a negative number, JavaScript returns a special value
               known as "*negative zero*", indistinguishable from regular zero.
- Division by zero :: division by zero is not an error in JavaScript. It simply
     returns infinity or negative infinity. There is one exception: zero divided
     by zero, the result of this operation is the special not-a-number value,
     printed as *NaN*.

NaN also arises if you attempt to divide infinity by infinity, or take the square
root of a negative number or use arithmetic operators with non-numeric operation
that cannot be converted to numbers. NaN does not compare equal to any other
value, including itself. x != x will be true if and only if x is NaN.

The negative zero value is also somewhat unusual. It compares equal (even using
JavaScript's strict equality test) to positive zero, except when used as a
divisor.
**** Binary Floating-Point and Rounding Errors
The IEEE-754 floating-point representation used by JavaScript is a binary
representation, which can exactly represent fractions like 1/2, 1/8, and 1/1024.
Unfortunately, the fractions we use most commonly are decimal fractions 1/10,
1/100, and so on. Binary floating-point representations cannot exactly represent
numbers as simple as 0.1.

A future version of JavaScript may support a decimal numeric type that avoids
these rounding issues. Performing critical financial calculations use scaled
integers.
**** Dates and Times
Use a =Date()= constructor for creating objects that represent dates and times.
*** Text
    :PROPERTIES:
    :CUSTOM_ID: text
    :END:
A string is an immutable ordered sequence of 16-bit values, each of which
typically represents a Unicode character.
**** String Literals
Simply enclose the characters of the string within a matched single or double
quotes. Double-quote characters may be contained within strings delimited by
single-quote characters, and single-quote characters may be contained within
strings delimited by double-quote characters.

In ECMAScript 3, string literals must be written on a single line. In ECMAScript
5, you can  break a string literal across multiple lines by ending each line but
the last with a backslash.

When you use single quotes to delimit your strings, you must use the backslash
character to escape. In client-side JavaScript programming, JavaScript code may
contain strings of HTML code may contain strings of JavaScript code. When
combining JavaScript and HTML, it's a good idea to use one style of quotes for
JavaScript and the other style for HTML. For example,
#+begin_src javascript
  <button onclick="alert('Thank you')">Click Me</button>
#+end_src
**** Escape Sequences in String Literals
The backslash character has a special purpose for escape special characters.
For instance, \n is an escape sequence that represents a newline character.
\u escape represents an arbitrary Unicode character specified by four
hexadecimal digits. \x escape represents Latin-1 encoding.
**** Working with Strings
Use + operator on strings, it joins them by appending the second to the first.
Use the length property of the string to determine the length of a string -
the number of /16-bit/ values it contains. There are many other methods working
with strings. Remember that strings are immutable in JavaScript. Methods like
=replace()= and =toUpperCase()= return /new/ strings!

In ECMAScript 5, strings can be treated like read-only arrays, and you can
access individual characters from a string using square brackets instead of the
=charAt()= method.
**** Pattern Matching
JavaScript adopts Perl's syntax for regular expressions. Although RegExps are
not one of the fundamental data types in the language, they do have a literal
syntax and can be encoded directly into JavaScript programs. Text between a pair
of slashes constitutes a regular expression literal. The second slash in the
pair can also be followed by one or more letters, which modify the meaning of
the pattern. RegExp objects define a number of useful methods, and strings also
have methods that accept RegExp arguments.
*** Boolean Values
    :PROPERTIES:
    :CUSTOM_ID: booleanValues
    :END:
All objects (and arrays) convert to, and work like, *true*. *false*, and the six
values (undefined, null, 0, -0, NaN, "") that convert to it, are sometimes
called *falsy* values, and all other values are called *truthy*.
#+begin_src javascript
  if (o !== null) ... // the body of the if will be executed only if o is not null
  if (o) ...          // the body of the if only if o is not false or any falsy value
#+end_src

Boolean values have a =toString()= method that you can use to convert them to
the strings "true" or "false", but they do not have any other useful methods.
Three important boolean operators: &&, ||, !
*** null and undefined
    :PROPERTIES:
    :CUSTOM_ID: nullAndUndefined
    :END:
*null* usually used to indicate the absence of a value.
*undefined* represents value of variables have not been initialized and the
value you get when you query the value of an object property or array element
that does not exist. Functions without return value or the value of function
parameters for which no argument is supplied are return undefined.
undefined is a predefined global variable that is initialized to the undefined
value. In ECMAScript 5, undefined is /read-only/ in that version of the
language.

null and undefined both indicate an absence of value and can often be used
interchangeably. The equality operator == considers them to be equal. (Use
the strict equality operator === to distinguish them). Neither null nor
undefined have any properties or methods. Any access a property or method
can cause a TypeError.

In other words, undefined to represent a system-level, unexpected, or error-
like absence of value and null to represent program-level, normal, or expected
absence of value.
*** The Global Object
    :PROPERTIES:
    :CUSTOM_ID: theGlobalObject
    :END:
The /global object/ is a regular JavaScript object that serves a very important
purpose: the properties of this object are the globally defined symbols that are
available to a JavaScript program. When the JavaScript interpreter starts (or
whenever a web browser loads a new page), it creates a /new/ global object and
give it an initial set of properties that define.

The initial properties of the global object are not reserved words, but they
deserve to be treated as if they are.

In top-level code, you can use the JavaScript keyword *this* to refer to the
global objects.

When first created, the global object defines all of JavaScript's predefined
global values.
*** Wrapper Objects
    :PROPERTIES:
    :CUSTOM_ID: wrapperObjects
    :END:
The temporary objects created when you access a property of a string, number, or
boolean are known as /wrapper objects/. Once the property has been resolved, the
newly created object is discarded. There are not wrapper objects for the null
and undefined values.

JavaScript converts wrapper objects into the wrapped primitive value as
necessary, so the wrapper objects usually, but not always, behave just like the
primitive values. The == equality operator treats a value and its wrapper object
as equal, but you can distinguish them with the === strict equality operator.
The typeof operator also can distinguish them.
*** Immutable Primitive Values and Mutable Object References
    :PROPERTIES:
    :CUSTOM_ID: immutablePrimitiveValuesAndMutableObjectReferences
    :END:
Primitives are immutable: there is no way to change a primitive value. Primitive
are also compared by value: two values are the same only if they have the same
value. Strings are equal if and only if they have the same length and if the
character at each index is the same.

Objects are mutable: their values can change. Objects are sometimes called
/reference types/ to distinguish them from JavaScript's primitive types. Objects
are compared by /reference/: two object values are the same if and only if they
/refer/ to the same underlying object. Assigning an object or array to a
variable simply assigns the reference: it does not create a new copy of the
object. If you want to make a new copy of an object or array, you must
explicitly copy the properties of the object or the elements of the array.
*** Type Conversion
    :PROPERTIES:
    :CUSTOM_ID: typeConversion
    :END:
JavaScript is very /flexible/ about the types of values it requires. The
primitive-to-primitive conversions are relatively straightforward.

Conversion to strings is well-defined for all primitive values.

Conversion to numbers is just a little trickier. Strings can be parsed as number
convert to those numbers. Leading and trailing spaces are allowed. Any
characters are not part of a numeric literal cause the string-to-number
conversion to produce *NaN*. Some numeric conversion are surprising: true
converts to 1, and false and  the empty string "" convert to 0, null converts to
0, undefined converts to NaN.
**** Conversions and Equality
The strict equality operator === that does not perform conversions when testing
for equality. == operator never attempts to convert its operands to booleans.
**** Explicit Conversions
Although JavaScript performs many type conversions automatically, you may
sometimes need to perform an explicit conversion. The simplest way to perform an
explicit type conversion is to use the =Boolean()=, =Number()=, =String()=
functions.

Any value other than null or undefined has a =toString()= method and the result
of this method is usually the same as that returned by the =String()= function.
Caution: Object(3) => new Number(3), does not throw an exception. Instead, it
simply returns a newly created empty object.

Formatting and parsing numbers are common tasks in computer programs and
JavaScript has specialized functions and methods that provide more precise
control over number-to-string and string-to-number conversions.

The =toString()= method defined by the Number class accepts an optional argument
that specifies a radix, or base, for the conversion (base 10 for default).

When working with financial or scientific data, you may want convert numbers to
strings in ways that give you control over the number of decimal places or the
number of significant digits in the output. The Number class defines three
methods for these kinds of number-to-string conversions.
- =toFixed()= :: converts a number to string with a specified number of digits
                 after the decimal point. It never uses exponential notation.
- =toExponential()= :: converts a number to string using exponential notation,
     with one digit before the decimal point and a specified number of digits
     after the decimal point.
- =toPrecision()= :: converts a number to string with the number of significant
     digits you specify. It uses exponential notation if the number of
     significant digits is not large enough to display the entire integer
     portion of the number.
All three methods /round/ the trailing digits or /pad with zeros/ as
appropriate.

If you pass a string to the =Number()= conversion function, it attempts to parse
that string as an integer or floating-point literal. ONLY works for base-10
integers and does not allow trailing characters that are not part of the
literal.
The =parseInt()= and =parseFloat()= are global functions, not method of any
class. =parseInt()= parses only integers. =parseFloat()= parses both integers
and floating-point numbers. Both =parseInt()= and =parseFloat()= skip leading
white-space, parse as many numeric characters as they can. If the first non-space
character is not part of a valid numeric literal, they return NaN.
=parseInt()= accepts an optional second argument specifying the radix (legal
value between 2 and 36) of the number to be parsed.
**** Object to Primitive Conversion
- Object-to-boolean conversion :: all objects converts to true, including
     wrapper objects.
- Object-to-string conversion :: only to native objects. Performed by invoking
     a method of the object to be converted.
- Object-to-number :: only to native objects. Performed by invoking
     a method of the object to be converted.

All objects inherit two conversion methods.

The first is called =toString()=, and its job is to return a string
representation of the object. The default =toString()= method does not return a
very interesting value. For example,
#+begin_src javascript
  ({x:1, y:2}).toString()         // => "[object object]"
#+end_src
Many classes define more specific version of the =toString()= method.
The =toString()= method of the /Array/ class converts each array element to a
string and joins the resulting strings together with commas in between.
The =toString()= method of the /Function/ class returns an
implementation-defined representation of a function. In practice, convert user-
defined functions to strings of JavaScript source code.
The =toString()= method of the /Date/ class returns a human-readable date and
time string.
The =toString()= method of the /RegExp/ class returns a string that looks like
a RegExp literal.

The other object conversion function is called =valueOf()=. The job of the
method is less well-defined. Objects are compound values, and most object cannot
really be represented by a single primitive value.
The /Wrapper/ classes define =valueOf()= methods that return the wrapped
primitive value.
Arrays, functions, and regular expressions simply inherit the default method.
Calling =valueOf()= for instances of these types simply returns the object
itself.
The /Date/ class defines a =valueOf()= method that returns the date in its
internal representation: the number of milliseconds since Jan. 1, 1970.

The rules on converting an object to a string:
+ If the object has a =toString()= method, JavaScript calls it. If it returns a
  primitive value, JavaScript converts that value to a string (if it is not
  already a string) and returns the result of that conversion.
+ If the object has no =toString()= method, or if that method does not return a
  primitive value, then JavaScript looks for a =valueOf()= method. If the method
  exists, JavaScript calls it. If the return value is a primitive, JavaScript
  converts that value to a string (if it is not already) and return the
  converted value.
+ Otherwise, JavaScript cannot obtain a primitive value from either =toString()=
  or =valueOf()=, so it throws a TypeError.

The rules on converting an object to a number: (does the same thing, but try
the =valueOf()= method first):
+ If the object has a =valueOf()= method that returns a primitive value,
  JavaScript converts that primitive value to a number and returns the result.
+ Otherwise, if the object has a =toString()= method that returns a primitive
  value, JavaScript converts and returns the value.
+ Otherwise, JavaScript throws a TypeError.

The object-to-primitive conversion used by + and == operator includes a special
case for Date objects. The Date class is the only predefined core JavaScript
type that define meaningful conversions to both strings and numbers. The
object-to-primitive conversion is basically an object-to-number conversion for
all objects that are not dates, and an object-to-string conversion for Date
objects. The primitive value returned by =valueOf()= or =toString()= is used
directly without being forced to a number or string.
The < operator and the other relational operators perform object-to-primitive
conversions like == does, but without the special case for Date objects: any
object is converted by trying =valueOf()= first and then =toString()=. Whatever
primitive value is obtained is used directly.

*Conclusion*: +, ==, != and the relational operators are the only ones that
perform this special kind of string-to-primitive conversions. Other operators
convert more explicitly to a specified type and do not have any special case
for Date objects. For examples:
#+begin_src javascript
  var now = new Date;
  typeof(now + 1)                 // "string": + converts dates to strings
  typeof(now - 1)                 // "number": - converts dates to numbers
  now == now.toString()           // true: implicit and explicit string conversions
  now > (now - 1)                 // true: converts a Date to a number
#+end_src
*** Variable Declaration
    :PROPERTIES:
    :CUSTOM_ID: variableDeclaration
    :END:
Before you use a variable in a JavaScript program, you should /declare/ it with
keyword /var/. You can write codes like these:
#+begin_src javascript
  var i;                          // declare a variable i, but not undefined
  var sum;
  var i, sum;                     // 3 methods for declaring variables, the same thing
  var message = "hello";
  var i = 0, j = 0, k = 0;        // always right
  for(var i = 0; i < 10; i++) console.log(i);
  for(var p in o) console.log(p); // var statement can also appear as part of the for and for/in loops
#+end_src
If you assign a value to an undeclared variable, JavaScript actually creates
that variable as a property of the global object. (Bad habit and a source of
bug)
*** Variable Scope
    :PROPERTIES:
    :CUSTOM_ID: variableScope
    :END:
The /scope/ of a variable is the region of your program source code in which it
is defined.
A /global/ variable has global scope, the /local/ variable has local scope.
Function parameters also count as local variables and are defined only within
the body of the function. You /must/ always use var to declare local variables.
JavaScript uses *function* scope, it means that all variables declared within a
function are visible /throughout/ the body of the function. Curiously, this
means that variables are even visible before they are declared.

In programming languages with block scope, it is generally good programming
practice to declare variables as close as possible to where they are used and
with the narrowest possible scope. JavaScript is a function scope programming
language, it is a good habit to declare all variables at the top of the function
which accurately reflect the true scope of the variables.

When you declare a global JavaScript variable, what you are actually doing is
defining a property of the global object. If you use var to declare the variable
, the property that is created is /nonconfigurable/, which means it cannot be
deleted with the delete operator. For example,
#+begin_src javascript
  var truevar = 1;  // a properly declared global variable, nondeletable
  fakevar = 2;      // creates a deletable property of the global object
  this.fakevar2 = 1;              // this does the same thing
  delete truevar;                 // => false
  delete fakevar;                 // => true
  delete this.fakevar2;           // => true
#+end_src
Every chunk of JavaScript code (global code or functions) has a /scope chain/
associated with it. This scope chain is a list or chain of objects that defines
the variables that are "in scope" for that code.

In top-level JavaScript code, the scope chain consists of a single object, the
global object. In a non-nested function, the scope chain consists of two objects
(The first is the object that defines the function's parameters and local
variables, and the second is the global object). In a nested function, the scope
chain has three or more objects.
When a function is defined, it stores the scope chain then in effect. When that
function is invoked, it creates a /new/ object to store its local variables, and
adds that new object to the stored scope chain to create a new, longer, chain
that represents the scope for that function invocation. This becomes more
interesting for nested functions because each time the outer function is called,
the inner function is defined again. Since the scope chain differs on each
invocation of the outer function, the inner function will be subtly different
each time it is defined.

Two great article on execution context and scope chain. [From David Shariff]
Links:
[[http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/][What is the Execution Context & Stack in JavaScript?]]
[[http://davidshariff.com/blog/javascript-scope-chain-and-closures/][Identifier Resolution and Closures in the JavaScript Scope Chain]]
** Expressions and Operators
   :PROPERTIES:
   :CUSTOM_ID: expressionsAndOperators
   :END:
*** Property Access Expressions
    :PROPERTIES:
    :CUSTOM_ID: propertyAccessExpressions
    :END:
A property access expression evaluates to the value of an object property or an
array element. JavaScript defines two syntaxes for property access:
=expression.identifier= or =expression[expression]= With either type of property
access expression, the expression before the . or [ is first evaluated. If the
value is null or undefined, the expression throws a TypeError.

The .identifier syntax is the simpler of the two property access options, but
notice that it can only be used when the property you want to access has a name
that is *a legal identifier*, and when you know the name when you write code. If
the property name is /a reserved word/ or /includes spaces or punctuation
characters/, or when it is /a number/, you must use the square bracket notation.
Square brackets are also used when the property name is /not static/ but is
itself the result of a computation.
*** Invocation Expressions
    :PROPERTIES:
    :CUSTOM_ID: invocationExpressions
    :END:
An /invocation expression/ JavaScript's syntax for calling a function or method.
When an invocation expression is evaluated, the function expression is evaluated
first, and then the argument expressions are evaluated to produce a list of
argument values. If the value of the function expression is not a callable
object, a TypeError is thrown. If the function uses a return statement to return
a value, then that value becomes the value of the invocation expression.
Otherwise, the value of the invocation expression is *undefined*.
Every invocation expression includes a pair of parentheses and an expression
before the open parenthesis. If that expression is a property access expression,
then the invocation is known as a /method invocation/. In method invocation, the
object or array that is the subject of the property access becomes the value of
the /this/ parameter while the body of the function is being executed.
Invocation expressions that are not method invocations normally use the global
object as the value of the this keyword.
*** Operator Overview
    :PROPERTIES:
    :CUSTOM_ID: operatorOverview
    :END:
Note that most operators are represented by punctuation characters. Some,
however, are represented by keywords such as /delete/ and /instanceof/. Keywords
operators are regular operators.
**** Number of Operands
Operators can be categorized based on the number of operands they expect. Most
JavaScript operators are /binary operators/. JavaScript also supports a number
of /unary operators/. Finally, it supports one /ternary operator/, the
conditional operator =? :=, which combines three expressions into a single
expression.
**** Operand and Result Type
Some operators work on values of any type, but most expect their operands to be
of a specific type, and most operators return a value of a specific type.

JavaScript operators usually convert the type of their operands as needed.
Remember also that every JavaScript value is either "truthy" or "falsy", so
operators that expect boolean operands will work with an operand of any type.

Some operators behave differently depending on the type of the operands used
with them.
**** Operator Side Effects
Some operands like (=, ++, --, delete) have /side effect/. No other JavaScript
operators have side effects, but function invocation and object creation
expressions will have side effects if any of the operators used in the function
or constructor body have side effects.
**** Order of Evaluation
Operator precedence and associativity specify the order in which operations are
performed in a complex expression, but they do not specify the order in which
the sub-expressions are evaluated.
*** Arithmetic Expressions
    :PROPERTIES:
    :CUSTOM_ID: arithmeticExpressions
    :END:
The basic arithmetic operators are (*, /, %, +, -). They evaluate their operands
, convert the values to numbers if necessary. Non-numeric operands that cannot
convert to numbers convert to the NaN value. If either operand is NaN, the
result of the operation is also NaN.
In JavaScript, all numbers are floating-point. Division by zero yields positive
or negative infinity, while 0/0 evaluates to NaN: neither of these cases raises
an error.
The sign of the result of the % operator is the same as the sign of the first
operand.
**** The + Operator
If either of the operands is a string or an object that converts to a string,
the other operand is converted to a string and concatenation is performed.
Addition is performed only if neither operand is string-like.
*Caution*: null -> number  // => 0; undefined -> number // => NaN
It is important to note that when the + operator is used with strings and
numbers, it may not be associative. That is, the result may depend on the order
in which operations are performed. For example,
#+begin_src javascript
  1 + 2 + " blind mice"           // => "3 blind mice"
  1 + (2 + " blind mice")         // => "12 blind mice"
#+end_src
**** Unary Arithmetic Operators
In JavaScript, the unary operators all have high precedence and are all right-
associative. The arithmetic unary operators convert their single operand to a
number, if necessary. Increment operators (both ++ and --) have lvalue operand.
Note that the expression ++x is not always the same as x = x + 1.
*** Relational Expressions
    :PROPERTIES:
    :CUSTOM_ID: relationalExpressions
    :END:
The == operator checks whether its two operands are equal, allowing type
conversion.
The strict equality === operator evaluates its operands, and then compare the
two values as follows, performing no type conversion.
Conclusion: Both the + operator and the comparison operators behave differently
for numeric and string operands. + favors strings: it performs concatenation if
either operand is a string. The comparison operators favor numbers and only
perform string comparison if both operands are strings.
**** The in Operator
The /in/ operator expects a left-hand operand that is or can be converted to a
string. It expects a right-hand operand that is an object. It evaluates to true
if the left-hand value is the name of a property of the right-hand object.
**** The instanceof Operator
The /instanceof/ operator expects a left-hand operand that is an object and a
right-hand operand that identifies a class of objects. The operator evaluates to
true if the left-hand object is an instance of the right-hand class.
If the left-hand operand of /instanceof/ is not an object, /instanceof/ returns
false. If the right-hand side is not a function, it throws a TypeError.
*** Logical Expressions
    :PROPERTIES:
    :CUSTOM_ID: logicalExpressions
    :END:
**** Logical And (&&)
The && operator can be understood at three different levels.
1. when used with boolean operands, it returns true if and only if both its
   operand and its second operand are true.
2. && does not require that its operands be boolean values. The && operator can
   understand truthy and falsy values. If both operands are truthy, the operator
   returns a truthy value, otherwise, a falsy value.
3. This operator starts by evaluating its first operand, the expression on its
   left. If the value on the left is falsy, so && simply returns the value on
   the left and does not even evaluate the expression on the right. If the value
   on the left is truthy, then the overall value of the expression depends on
   the value on the right-hand side.

In general, you must be careful whenever you write an expression with side
effects on the right-hand side of &&. Whether those side effects occur depends
on the value of the left-hand side.
**** Logical Or (||)
Like && operator. It starts by evaluating its first operand, the expression on
its left. If the value of this first operand is truthy, it returns that truthy
value. Otherwise, it evaluates its second operand, the expression on its right,
and returns the value of that expression.
**** Logical NOT (!)
Unlike the && and || operators, the ! operator converts its operand to a boolean
value before inverting the converted value. This means that ! always returns
true or false, and you can convert any value x to its equivalent boolean value
by applying this operator twice: !!x
**** The delete Operator
/delete/ is an unary operator that attempts to delete the object property or
array element specified as its operand. Deleting an array element leaves a
"hole" in the array and does not change the array's length. The resulting array
is sparse.
/delete/ expects its operand to be an lvalue. If it is not an lvalue, the
operator takes no action and returns true. Not all properties can be deleted.
Some built-in core and client-side properties are immune from deletion, and user
-defined variables declared with the var statement cannot be deleted. Functions
defined with the function statement and declared function parameters can not be
deleted either.

In ECMAScript 5 strict mode, /delete/ raises a SyntaxError if its operand is an
unqualified identifier. Also specifies that /delete/ raises a syntaxError if
asked to delete any nonconfigurable property.
** Statements
   :PROPERTIES:
   :CUSTOM_ID: statements
   :END:
Expressions are evaluated to produce a value, but statements are executed to
make something happen (create side effects).
*** Declaration Statements
    :PROPERTIES:
    :CUSTOM_ID: declarationStatements
    :END:
**** function
#+begin_src javascript
  var f = function(x) { return x+1; }; // Expression assigned to a variable
  function f(x) { return x+1; }        // Statement includes variable name
#+end_src
Function declaration statements may appear in top-level JavaScript code, or they
may be nested within other functions. When nested, however, function
declarations only appear at the top level of the function they are nested
within.
Function declaration statements diff from function definition expressions in
that they include a function name. Both forms create a new function objects,
but the function declaration statement also declares the function name as a
variable and assigns the function object to it. Like variables declared with
/var/, function defined with function definition statements are implicitly
"hoisted" to the top of the containing script or function, so that they are
visible throughout the script or function. With /var/, *only* the variable
declaration is hoisted - the variable initialization code *remains* where you
place it. This means that you can invoke a JavaScript function before you
declare it.
*** Conditionals
    :PROPERTIES:
    :CUSTOM_ID: conditionals
    :END:
**** switch
ECMAScript standard allows each /case/ to be followed by an arbitrary
/expression/. The /switch/ statement first evaluates the expression that follows
the /switch/ keyword and then evaluates the /case/ expressions, in the order in
which they appear, until it finds a value that matches (use strict compare).
Because not all of the /case/ expressions are evaluated each time the /switch/
statement is executed, you should avoid using /case/ expressions that contain
side effects. The safest course is simply to limit your /case/ expressions to
constant expressions.
*** Loops
    :PROPERTIES:
    :CUSTOM_ID: loops
    :END:
**** do/while
The do/while loop is executed at least once, and requires both do keyword and
the while keyword. Also, the do loop must always be terminated with a semicolon.
**** for/in
A for/in loop looks like this:
#+begin_src javascript
  for (variable in object)
    statement
#+end_src
/variable/ must be a lvalue, /object/ is an expression that evaluates to an
object.
To execute a for/in statement, the JavaScript interpreter first evaluates the
object expression. If it evaluates to null or undefined, the interpreter skips
the loop and moves to the next statements. If it evaluates to a primitive value,
that value is converted to its equivalent wrapper object. Otherwise, an object.
The interpreter now executes the body of the loop once for each enumerable
property of the object. Before each iteration, however, the interpreter
evaluates the variable expression and assigns the name of the property to it.

The for/in loop does not actually enumerate all properties of an object, only
the /enumerable/ properties. The various built-in methods defined by core
JavaScript are not enumerable. In addition to built-in methods, many other
properties of the built-in objects are non-enumerable. All properties and method
defined by your code are enumerable.
*** Jumps
    :PROPERTIES:
    :CUSTOM_ID: jumps
    :END:
The /break/ statement makes the interpreter jump to the end of a loop or other
statement. /continue/ makes the interpreter skip the rest of the body of a loop
and jump back to the top of a loop to begin a new iteration.
JavaScript allows statements to be named, or labeled, and the break and continue
can identify the target loop or other statement label.

The /return/ statement makes the interpreter jump from a function invocation
back to the code invoked it and also supplies the value for the invocation. The
/throw/ statement raises, or "throws," an exception and is designed to work with
the try catch finally statement.
**** Labeled Statements
It is only useful to label statements that have bodies, such as loops and
conditionals. /break/ and /continue/ are the only JavaScript statements that use
statement labels. You can use the same identifier as a statement label and as a
variable or function name. A statement may not have the same label as a
statement that contains it. Any statement may have multiple labels.
**** break
The /break/ statement causes the innermost enclosing loop or switch statement to
exit immediately. This form of the /break/ statement is legal only if it appears
inside one of these statements.

When you want to break out of a statement that is not the nearest enclosing loop
or a switch you need the labeled form of the /break/ statement. You cannot label
a function definition statement.
**** continue
Similar to the break statement, in both its labeled and unlabeled forms, can be
used only within the body of a loop.
**** return
A return statement may appear only within the body of a function. A function
returns to its caller when a return statement is executed, even if there are
other statements remaining in the function body. If there is no return
statement, /undefined/ is returned.
**** throw
