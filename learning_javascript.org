#+TITLE: Learning JavaScript
#+LANGUAGE: EN
#+AUTHOR: Yang Jie
#+EMAIL: outstanding.yang@gmail.com
#+DESCRIPTION: My notes on reading "JavaScript - The Definitive Guide 6th Edition"

JavaScript is the programming language of the Web. JavaScript is part of triad
of technologies that all Web developers must learn: *HTML* to specify the
content of web pages, *CSS* to specify the presentation of web pages, and
*JavaScript* to specify the behavior of web pages.

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:
Main structure of the book.
** Core JavaScript
   :PROPERTIES:
   :CUSTOM_ID: coreJavascript
   :END:
This is the lowest level of JavaScript including Lexical Structure, Types,
Values, Variables, Expressions and Operators, Statements, Objects, Arrays,
Functions, Classes and Modules, Pattern Matching with Regular Expressions,
JavaScript Subsets and Extensions.
** Client-Side JavaScript
   :PROPERTIES:
   :CUSTOM_ID: clientSideJavascript
   :END:
Client-Side JavaScript does not exhibit the nonlinear cross-reference problem
nearly to the extent that the core language does, and it is possible to learn
how to use JavaScritp in web browsers in a fairly linear sequence.
* Getting Started
  :PROPERTIES:
  :CUSTOM_ID: gettingStarted
  :END:
** Lexical Structure
   :PROPERTIES:
   :CUSTOM_ID: lexicalStructure
   :END:
*** Character Set
    :PROPERTIES:
    :CUSTOM_ID: characterSet
    :END:
JavaScript programs are written using the Unicode character set.

JavaScript is a case-sensitive language, but HTML is not case-sensitive
(although XHTML is). Many client-side JavaScript objects and properties have the
same names as the HTML tags and attributes. Please be care!

JavaScript ignores spaces that appear between tokens in programs. Because you
can use spaces and newlines freely in your programs, you can format and indent
your programs in a neat and consistent way.

JavaScript defines special sequences of six ASCII character to represent any
16-bit Unicode codepoint. Unicode escapes begin with the characters \u and are
followed by exactly four hexadecimal digits. They may appear in JavaScript
string literals, and in identifiers (but not in language keywords). Also they
may appear in comments, but not interpreted as Unicode.
*** Comments
    :PROPERTIES:
    :CUSTOM_ID: comments
    :END:
Two styles of comments:
1. Any text between a // and the end of a line.
2. Any text between the charaters /* and */, these comments may span multiple
   lines but may not be nested.
*** Literals
    :PROPERTIES:
    :CUSTOM_ID: literals
    :END:
A literal is a data value that appears directly in a program.
*** Identifiers and Reserved Words
    :PROPERTIES:
    :CUSTOM_ID: identifiers
    :END:
A JavaScript identifier must begin with a letter, an underscore, or a dollor
sign. Subsequent characters can be letters, digits, underscores, or dollor sign.
Digits are /not/ allowed as the first character.

JavaScript reserves a number of identifiers as the keywords of the language
itself. They are not allowed as variable, function, or parameter names.
*** Optional Semicolons
    :PROPERTIES:
    :CUSTOM_ID: optionSemicolons
    :END:
JavaScript uses the semicolon to separate statements from each other. In
JavaScript, you can usually omit the semicolon between two statements if those
statements are written on separate lines. You should always use semicolons to
explicitly mark the ends of statements, even where they are not required.

There are two exceptions to the general rule that JavaScript interprets line
breaks as semicolons when it cannot parse the second line as a continuation of
the statement on the first line.
1. return, break, and continue: You must not insert a line break between return,
   break, or continue and the expression that follows the keyword.
2. ++ and -- operators: as postfix operator, they must appear on the same line
   as the expression they apply to.
** Types, Values, and Variables
   :PROPERTIES:
   :CUSTOM_ID: typesValuesVariables
   :END:
Computer programs work by manipulating /values/, such as the number 3.14 or the
text "hello world". The kinds of values that can be represented and manipulated
in a programming language is the set of /types/ it supports. When a program
needs to retain a value for future use, it assigns the value to a /variable/.

JavaScript types can be divided into two categories:
- Primitive types :: numbers, strings, booleans, null, and undefined
- Object types :: Not primitive types are objects types
And types with methods and types without. Also, *mutable* and *immutable* types.

JavaScript object is an unordered collection of named values. The language
defines a special kind of object - /array/ that represents an ordered collection
of numbered values. Another special kind of object is a /function/ which has
excutable code associated with it. The most important thing about functions in
JavaScript is that they are true values and JavaScript programs can treat them
like regular objects.

*Functions* that are written to be used (with the *new* operator) to initialize
a newly created object are known as /constructors/. Each constructor defines a
class of objects - the set of objects initialized by that constructor. *Classes*
can be thought of as subtypes of the object type. In addition to the *Array* and
*Function* classes, core JavaScript defines three other useful classes. The
*Date* class represents dates, the *RegExp* class represents regular expressions
and the *Error* class represents syntax and runtime errors. You can define your
own classes of objects by defining appropriate constructor functions.

The JavaScript interpreter performs /automatic garbage collection/ for memory
management.
JavaScritp is an object-oriented language. It means that rather than having
globally defined functions to operate on values of various types, the types
themselves define /methods/ for working with values. Only JavaScript objects
have methods. But numbers, strings, boolean values behave as if they had method.
In JavaScript, /null/ and /undefined/ are the only values that methods cannot be
invoked on.
JavaScript variables are /untyped/. Variables are declared with the *var*
keyword. JavaScript uses /lexical scoping/.
*** Numbers
    :PROPERTIES:
    :CUSTOM_ID: numbers
    :END:
All numbers in JavaScript are represented as floating-point values. When a
number appears directly in a JavaScript program, it's called a /numeric literal/
. A minus sign makes number negative, but - is the unary negation operator and
is not part of the numeric literal syntax.
**** Integer Literals
base-10, base-16, and base-8 integer literals. A hexadecimal literal begins with
"0x" or "0X", followed by a string of hexadecimal digits. Although ECMAScript
standard does not support hexadecimal literals, some implementations of
JavaScript allow you to specify integer literals in octal. In the strict mode of
ECMAScript 5, octal literals are explicitly forbidden.
**** Floating-Point Literals
syntax: [digits][.digits][(E|e)[(+|-)]digits]
**** Arithmetic in JavaScript
JavaScript programs work with numbers using the arithmetic operators that the
language provides. In addition to basic arithmetic operators, JavaScript
supports more complex mathematical operations through a set of functions and
constants defined as properties of the *Math* object.

Arithmetic in JavaScript does not raise errors in cases of overflow, underflow,
or division by zero.
- Overflow :: when the result of a numeric operation is larger than the largest
              representable number, JavaScript prints as *Infinity*; contrastly,
              prints as *-Infinity*
- Underflow :: when the result of a numeric operation is closer to zero than the
               smallest representable number, JavaScript retures 0; If underflow
               occurs from a negtive number, JavaScript returns a special value
               known as "*negative zero*", indistinguishable from regular zero.
- Division by zero :: division by zero is not an error in JavaScript. It simply
     returns infinity or negtive infinity. There is one exception: zero divided
     by zero, the result of this operation is the special not-a-number value,
     printed as *NaN*.

NaN also arises if you attempt to divide infinity by infinity, or take the squre
root of a negative number or use arithmetic operators with non-numeric operation
that cannot be converted to numbers. NaN does not compare equal to any other
value, including itself. x != x will be true if and only if x is NaN.

The negative zero value is also somewhat unusual. It compares equal (even using
JavaScript's strict equality test) to positive zero, except when used as a
divisor.
**** Binary Floating-Point and Rounding Errors
The IEEE-754 floating-point representation used by JavaScript is a binary
representation, which can exactly represent fractions like 1/2, 1/8, and 1/1024.
Unfortunately, the fractions we use most commonly are decimal fractions 1/10,
1/100, and so on. Binary floating-point representations cannot exactly represent
numbers as simple as 0.1.

A future version of JavaScript may support a decimal numeric type that avoids
these rounding issues. Performing critical financial calculations use scaled
integers.
**** Dates and Times
Use a =Date()= constructor for creating objects that represent dates and times.
*** Text
    :PROPERTIES:
    :CUSTOM_ID: text
    :END:
A string is an immutable ordered sequence of 16-bit values, each of which
typically represents a Unicode character.
**** String Literals
Simply enclose the characters of the string within a matched single or double
quotes. Double-quote characters may be contained within strings delimited by
single-quote characters, and single-quote characters may be contained within
strings delimited by double-quote characters.

In ECMAScript 3, string literals must be written on a single line. In ECMAScript
5, you can  break a string literal across multiple lines by ending each line but
the last with a backslash.

When you use single quotes to delimit your strings, you must use the backslash
character to escape. In client-side JavaScript programming, JavaScript code may
contain strings of HTML code may contain strings of JavaScript code. When
combining JavaScript and HTML, it's a good idea to use one style of quotes for
JavaScript and the other style for HTML. For example,
#+begin_src javascript
  <buttton onclick="alert('Thank you')">Click Me</button>
#+end_src
**** Escape Sequences in String Literals
The backslash character has a special purpose for escape special characters.
For instance, \n is an escape sequence that represents a newline character.
\u escape represents an arbitrary Unicode character specified by four
hexadecimal digits. \x escape represents Latin-1 encoding.
**** Working with Strings
Use + operator on strings, it joins them by appending the second to the first.
Use the length property of the string to determine the length of a string -
the number of /16-bit/ values it contains. There are many other methods working
with strings. Remember that strings are immutable in JavaScript. Methods like
=replace()= and =toUpperCase()= return /new/ strings!

In ECMAScript 5, strings can be treated like read-only arrays, and you can
access individual characters from a string using square brackets instead of the
=charAt()= method.
**** Pattern Matching
JavaScript adopts Perl's syntax for regular expressions. Although RegExps are
not one of the fundamental data types in the language, they do have a literal
syntax and can be encoded directly into JavaScript programs. Text between a pair
of slashes constitutes a regular expression literal. The second slash in the
pair can also be followed by one or more letters, which modify the meaning of
the pattern. RegExp objects define a number of useful methods, and strings also
have methods that accept RegExp arguments.
*** Boolean Values
    :PROPERTIES:
    :CUSTOM_ID: booleanValues
    :END:
All objects (and arrays) convert to, and work like, *true*. *false*, and the six
values (undefined, null, 0, -0, NaN, "") that convert to it, are sometimes
called *falsy* values, and all other values are called *truthy*.
#+begin_src javascript
  if (o !== null) ... // the body of the if will be executed only if o is not null
  if (o) ...          // the body of the if only if o is not false or any falsy value
#+end_src

Boolean values have a =toString()= method that you can use to convert them to
the strings "true" or "false", but they do not have any other useful methods.
Three important boolean operators: &&, ||, !
*** null and undefined
    :PROPERTIES:
    :CUSTOM_ID: nullAndUndefined
    :END:
*null* usually used to indicate the absence of a value.
*undefined* represents value of variables have not been initialized and the
value you get when you query the value of an object property or array element
that does not exist. Functions without return value or the value of function
parameters for which no argument is supplied are return undefined.
undefined is a predefined global variable that is initialized to the undefined
value. In ECMAScript 5, undefined is /read-only/ in that version of the
language.

null and undefined both indicate an absence of value and can often be used
interchangeably. The equality operator == considers them to be equal. (Use
the strict equality operator === to distinguish them). Neither null nor
undefined have any properties or methods. Any access a property or method
can cause a TypeError.

In other words, undefined to represent a system-level, unexpected, or error-
like absence of value and null to represent program-level, normal, or expected
absence of value.
*** The Global Objec
    :PROPERTIES:
    :CUSTOM_ID: theGlobalObject
    :END:
The /global object/ is a regular JavaScript object that serves a very important
purpose: the properties of this object are the globally defined symbols that are
available to a JavaScript program. When the JavaScript interpreter starts (or
whenever a web browser loads a new page), it creates a /new/ global object and
give it an initial set of properties that define.

The initial properties of the global object are not reserved words, but they
deserve to be treated as if they are.

In top-level code, you can use the JavaScript keyword *this* to refer to the
global objects.

When first created, the global object defines all of JavaScript's predefined
global values.
*** Wrapper Objects
    :PROPERTIES:
    :CUSTOM_ID: wrapperObjects
    :END:
The temporary objects created when you access a property of a string, number, or
boolean are known as /wrapper objects/. Once the property has been resolved, the
newly created object is discarded. There are not wrapper objects for the null
and undefined values.

JavaScript converts wrapper objects into the wrapped primitive value as
necessary, so the wrapper objects usually, but not always, behave just like the
primitive values. The == equality operator treats a value and its wrapper object
as equal, but you can distinguish them with the === strict equality operator.
The typeof operator also can distinguish them.
*** Immutable Primitive Values and Mutable Object References
    :PROPERTIES:
    :CUSTOM_ID: immutablePrimitiveValuesAndMutableObjectReferences
    :END:
Primitves are immutable: there is no way to change a primitive value. Primitive
are also compared by value: two values are the same only if they have the same
value. Strings are equal if and only if they have the same length and if the
charactor at each index is the same.

Objects are mutable: their values can change. Objects are sometimes called
/reference types/ to distinguish them from JavaScript's primitive types. Objects
are compared by /reference/: two object values are the same if and only if they
/refer/ to the same underlying object. Assigning an object or array to a
variable simply assigns the reference: it does not create a new copy of the
object. If you want to make a new copy of an object or array, you must
explicitly copy the properties of the object or the elements of the array.
*** Type Conversion
    :PROPERTIES:
    :CUSTOM_ID: typeConversion
    :END:
JavaScript is very /flexible/ about the types of values it requires. The
primitive-to-primitive conversions are relatively straightforward.

Conversion to strings is well-defined for all primitive values.

Conversion to numbers is juat a little trickier. Strings can be parsed as number
convert to those numbers. Leading and trailing spaces are allowed. Any
charactors are not part of a numeric literal cause the string-to-number
conversion to produce *NaN*. Some numeric conversion are suprising: true
converts to 1, and false and the empty string "" convert to 0.
**** Conversions and Equality
The strict equality operator === that does not perform conversions when testing
for equality. == operator never attempts to convert its operands to booleans.
**** Explicit Conversions
Although JavaScript performs many type conversions automatically, you may
sometimes need to perform an explicit conversion. The simplest way to perform an
explicit type conversion is to use the =Boolean()=, =Number()=, =String()=
functions.

Any value other than null or undefined has a =toString()= method and the result
of this method is usually the same as that returned by the =String()= function.
Caution: Object(3) => new Number(3), does not throw an exception. Instead, it
simply returns a newly created empty object.

Formatting and parsing numbers are common tasks in computer programs and
JavaScript has specialized functions and methods that provide more precise
control over number-to-string and string-to-number conversions.

The =toString()= method defined by the Number class accepts an optional argument
that specifies a radix, or base, for the conversion (base 10 for default).

When working with financial or scientific data, you may want convert numbers to
strings in ways that give you control over the number of decimal places or the
number of significant digits in the output. The Number class defines three
methods for these kinds of number-to-string conversions.
- =toFixed()= :: converts a number to string with a specified number of digits
                 after the decimal point. It never uses exponential notation.
- =toExponential()= :: converts a number to string using exponential notation,
     with one digit before the decimal point and a specified number of digits
     after the decimal point.
- =toPrecision()= :: converts a number to string with the number of significant
     digits you specify. It uses exponential notation if the number of
     significant digits is not large enough to display the entire integer
     portion of the number.
All three methods /round/ the trailing digits or /pad with zeros/ as
appropriate.

If you pass a string to the =Number()= conversion function, it attempts to parse
that string as an integer or floating-point literal. ONLY works for base-10
integers and does not allow trailing characters that are not part of the
literal.
The =parseInt()= and =parseFloat()= are global functions, not method of any
class. =parseInt()= parses only integers. =parseFloat()= parses both integers
and floating-point numbers. Both =parseInt()= and =parseFloat()= skip leading
whitespace, parse as many numeric characters as they can. If the first nonspace
character is not part of a valid numeric literal, they return NaN.
=parseInt()= accepts an optional second argument specifying the radix (legal
value between 2 and 36) of the number to be parsed.
**** Object to Primitive Conversion
- Object-to-boolean conversion :: all objects converts to true, including
     wrapper objects.
- Object-to-string conversion :: only to native objects. Performed by invoking
     a method of the object to be converted.
- Object-to-number :: only to native objects. Performed by invoking
     a method of the object to be converted.

All objects inherit two conversion methods.

The first is called =toString()=, and its job is to return a string
representation of the object. The default =toString()= method does not return a
very interesting value. For example,
#+begin_src javascript
  ({x:1, y:2}).toString()         // => "[object object]"
#+end_src
Many classes define more specific version of the =toString()= method.
The =toString()= method of the /Array/ class converts each array element to a
string and joins the resulting strings together with commas in between.
The =toString()= method of the /Function/ class returns an
implementation-defined representation of a function. In practice, convert user-
defined functions to strings of JavaScript source code.
The =toString()= method of the /Date/ class returns a human-readable date and
time string.
The =toString()= method of the /RegExp/ class returns a string that looks like
a RegExp literal.

The other object conversion function is called =valueOf()=. The job of the
method is less well-defined. Objects are compound values, and most object cannot
really be represented by a single primitive value.
The /Wrapper/ classes define =valueOf()= methods that return the wrapped
primitive value.
Arrays, functions, and regular expressions simply inherit the default method.
Calling =valueOf()= for instances of these types simply returns the object
itself.
The /Date/ class defines a =valueOf()= method that returns the date in its
internal representation: the number of milliseconds since Jan. 1, 1970.
