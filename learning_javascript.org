#+TITLE: Learning JavaScript
#+LANGUAGE: EN
#+AUTHOR: Yang Jie
#+EMAIL: outstanding.yang@gmail.com
#+DESCRIPTION: My notes on reading "JavaScript - The Definitive Guide 6th Edition"

JavaScript is the programming language of the Web. JavaScript is part of triad
of technologies that all Web developers must learn: *HTML* to specify the
content of web pages, *CSS* to specify the presentation of web pages, and
*JavaScript* to specify the behavior of web pages.

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:
Main structure of the book.
** Core JavaScript
   :PROPERTIES:
   :CUSTOM_ID: coreJavascript
   :END:
This is the lowest level of JavaScript including Lexical Structure, Types,
Values, Variables, Expressions and Operators, Statements, Objects, Arrays,
Functions, Classes and Modules, Pattern Matching with Regular Expressions,
JavaScript Subsets and Extensions.
** Client-Side JavaScript
   :PROPERTIES:
   :CUSTOM_ID: clientSideJavascript
   :END:
Client-Side JavaScript does not exhibit the nonlinear cross-reference problem
nearly to the extent that the core language does, and it is possible to learn
how to use JavaScript in web browsers in a fairly linear sequence.
* Getting Started
  :PROPERTIES:
  :CUSTOM_ID: gettingStarted
  :END:
** Lexical Structure
   :PROPERTIES:
   :CUSTOM_ID: lexicalStructure
   :END:
*** Character Set
    :PROPERTIES:
    :CUSTOM_ID: characterSet
    :END:
JavaScript programs are written using the Unicode character set.

JavaScript is a case-sensitive language, but HTML is not case-sensitive
(although XHTML is). Many client-side JavaScript objects and properties have the
same names as the HTML tags and attributes. Please be care!

JavaScript ignores spaces that appear between tokens in programs. Because you
can use spaces and newlines freely in your programs, you can format and indent
your programs in a neat and consistent way.

JavaScript defines special sequences of six ASCII character to represent any
16-bit Unicode codepoint. Unicode escapes begin with the characters \u and are
followed by exactly four hexadecimal digits. They may appear in JavaScript
string literals, and in identifiers (but not in language keywords). Also they
may appear in comments, but not interpreted as Unicode.
*** Comments
    :PROPERTIES:
    :CUSTOM_ID: comments
    :END:
Two styles of comments:
1. Any text between a // and the end of a line.
2. Any text between the characters /* and */, these comments may span multiple
   lines but may not be nested.
*** Literals
    :PROPERTIES:
    :CUSTOM_ID: literals
    :END:
A literal is a data value that appears directly in a program.
*** Identifiers and Reserved Words
    :PROPERTIES:
    :CUSTOM_ID: identifiers
    :END:
A JavaScript identifier must begin with a letter, an underscore, or a dollar
sign. Subsequent characters can be letters, digits, underscores, or dolor sign.
Digits are /not/ allowed as the first character.

JavaScript reserves a number of identifiers as the keywords of the language
itself. They are not allowed as variable, function, or parameter names.
*** Optional Semicolons
    :PROPERTIES:
    :CUSTOM_ID: optionSemicolons
    :END:
JavaScript uses the semicolon to separate statements from each other. In
JavaScript, you can usually omit the semicolon between two statements if those
statements are written on separate lines. You should always use semicolons to
explicitly mark the ends of statements, even where they are not required.

There are two exceptions to the general rule that JavaScript interprets line
breaks as semicolons when it cannot parse the second line as a continuation of
the statement on the first line.
1. return, break, and continue: You must not insert a line break between return,
   break, or continue and the expression that follows the keyword.
2. ++ and -- operators: as postfix operator, they must appear on the same line
   as the expression they apply to.
** Types, Values, and Variables
   :PROPERTIES:
   :CUSTOM_ID: typesValuesVariables
   :END:
Computer programs work by manipulating /values/, such as the number 3.14 or the
text "hello world". The kinds of values that can be represented and manipulated
in a programming language is the set of /types/ it supports. When a program
needs to retain a value for future use, it assigns the value to a /variable/.

JavaScript types can be divided into two categories:
- Primitive types :: numbers, strings, booleans, null, and undefined
- Object types :: Not primitive types are objects types
And types with methods and types without. Also, *mutable* and *immutable* types.

JavaScript object is an unordered collection of named values. The language
defines a special kind of object - /array/ that represents an ordered collection
of numbered values. Another special kind of object is a /function/ which has
executable code associated with it. The most important thing about functions in
JavaScript is that they are true values and JavaScript programs can treat them
like regular objects.

*Functions* that are written to be used (with the *new* operator) to initialize
a newly created object are known as /constructors/. Each constructor defines a
class of objects - the set of objects initialized by that constructor. *Classes*
can be thought of as subtypes of the object type. In addition to the *Array* and
*Function* classes, core JavaScript defines three other useful classes. The
*Date* class represents dates, the *RegExp* class represents regular expressions
and the *Error* class represents syntax and run-time errors. You can define your
own classes of objects by defining appropriate constructor functions.

The JavaScript interpreter performs /automatic garbage collection/ for memory
management.
JavaScript is an object-oriented language. It means that rather than having
globally defined functions to operate on values of various types, the types
themselves define /methods/ for working with values. Only JavaScript objects
have methods. But numbers, strings, boolean values behave as if they had method.
In JavaScript, /null/ and /undefined/ are the only values that methods cannot be
invoked on.
JavaScript variables are /untyped/. Variables are declared with the *var*
keyword. JavaScript uses /lexical scoping/.
*** Numbers
    :PROPERTIES:
    :CUSTOM_ID: numbers
    :END:
All numbers in JavaScript are represented as floating-point values. When a
number appears directly in a JavaScript program, it's called a /numeric literal/
. A minus sign makes number negative, but - is the unary negation operator and
is not part of the numeric literal syntax.
**** Integer Literals
base-10, base-16, and base-8 integer literals. A hexadecimal literal begins with
"0x" or "0X", followed by a string of hexadecimal digits. Although ECMAScript
standard does not support hexadecimal literals, some implementations of
JavaScript allow you to specify integer literals in octal. In the strict mode of
ECMAScript 5, octal literals are explicitly forbidden.
**** Floating-Point Literals
syntax: [digits][.digits][(E|e)[(+|-)]digits]
**** Arithmetic in JavaScript
JavaScript programs work with numbers using the arithmetic operators that the
language provides. In addition to basic arithmetic operators, JavaScript
supports more complex mathematical operations through a set of functions and
constants defined as properties of the *Math* object.

Arithmetic in JavaScript does not raise errors in cases of overflow, underflow,
or division by zero.
- Overflow :: when the result of a numeric operation is larger than the largest
              representable number, JavaScript prints as *Infinity*; contrastly,
              prints as *-Infinity*
- Underflow :: when the result of a numeric operation is closer to zero than the
               smallest representable number, JavaScript returns 0; If underflow
               occurs from a negative number, JavaScript returns a special value
               known as "*negative zero*", indistinguishable from regular zero.
- Division by zero :: division by zero is not an error in JavaScript. It simply
     returns infinity or negative infinity. There is one exception: zero divided
     by zero, the result of this operation is the special not-a-number value,
     printed as *NaN*.

NaN also arises if you attempt to divide infinity by infinity, or take the square
root of a negative number or use arithmetic operators with non-numeric operation
that cannot be converted to numbers. NaN does not compare equal to any other
value, including itself. x != x will be true if and only if x is NaN.

The negative zero value is also somewhat unusual. It compares equal (even using
JavaScript's strict equality test) to positive zero, except when used as a
divisor.
**** Binary Floating-Point and Rounding Errors
The IEEE-754 floating-point representation used by JavaScript is a binary
representation, which can exactly represent fractions like 1/2, 1/8, and 1/1024.
Unfortunately, the fractions we use most commonly are decimal fractions 1/10,
1/100, and so on. Binary floating-point representations cannot exactly represent
numbers as simple as 0.1.

A future version of JavaScript may support a decimal numeric type that avoids
these rounding issues. Performing critical financial calculations use scaled
integers.
**** Dates and Times
Use a =Date()= constructor for creating objects that represent dates and times.
*** Text
    :PROPERTIES:
    :CUSTOM_ID: text
    :END:
A string is an immutable ordered sequence of 16-bit values, each of which
typically represents a Unicode character.
**** String Literals
Simply enclose the characters of the string within a matched single or double
quotes. Double-quote characters may be contained within strings delimited by
single-quote characters, and single-quote characters may be contained within
strings delimited by double-quote characters.

In ECMAScript 3, string literals must be written on a single line. In ECMAScript
5, you can  break a string literal across multiple lines by ending each line but
the last with a backslash.

When you use single quotes to delimit your strings, you must use the backslash
character to escape. In client-side JavaScript programming, JavaScript code may
contain strings of HTML code may contain strings of JavaScript code. When
combining JavaScript and HTML, it's a good idea to use one style of quotes for
JavaScript and the other style for HTML. For example,
#+begin_src javascript
  <button onclick="alert('Thank you')">Click Me</button>
#+end_src
**** Escape Sequences in String Literals
The backslash character has a special purpose for escape special characters.
For instance, \n is an escape sequence that represents a newline character.
\u escape represents an arbitrary Unicode character specified by four
hexadecimal digits. \x escape represents Latin-1 encoding.
**** Working with Strings
Use + operator on strings, it joins them by appending the second to the first.
Use the length property of the string to determine the length of a string -
the number of /16-bit/ values it contains. There are many other methods working
with strings. Remember that strings are immutable in JavaScript. Methods like
=replace()= and =toUpperCase()= return /new/ strings!

In ECMAScript 5, strings can be treated like read-only arrays, and you can
access individual characters from a string using square brackets instead of the
=charAt()= method.
**** Pattern Matching
JavaScript adopts Perl's syntax for regular expressions. Although RegExps are
not one of the fundamental data types in the language, they do have a literal
syntax and can be encoded directly into JavaScript programs. Text between a pair
of slashes constitutes a regular expression literal. The second slash in the
pair can also be followed by one or more letters, which modify the meaning of
the pattern. RegExp objects define a number of useful methods, and strings also
have methods that accept RegExp arguments.
*** Boolean Values
    :PROPERTIES:
    :CUSTOM_ID: booleanValues
    :END:
All objects (and arrays) convert to, and work like, *true*. *false*, and the six
values (undefined, null, 0, -0, NaN, "") that convert to it, are sometimes
called *falsy* values, and all other values are called *truthy*.
#+begin_src javascript
  if (o !== null) ... // the body of the if will be executed only if o is not null
  if (o) ...          // the body of the if only if o is not false or any falsy value
#+end_src

Boolean values have a =toString()= method that you can use to convert them to
the strings "true" or "false", but they do not have any other useful methods.
Three important boolean operators: &&, ||, !
*** null and undefined
    :PROPERTIES:
    :CUSTOM_ID: nullAndUndefined
    :END:
*null* usually used to indicate the absence of a value.
*undefined* represents value of variables have not been initialized and the
value you get when you query the value of an object property or array element
that does not exist. Functions without return value or the value of function
parameters for which no argument is supplied are return undefined.
undefined is a predefined global variable that is initialized to the undefined
value. In ECMAScript 5, undefined is /read-only/ in that version of the
language.

null and undefined both indicate an absence of value and can often be used
interchangeably. The equality operator == considers them to be equal. (Use
the strict equality operator === to distinguish them). Neither null nor
undefined have any properties or methods. Any access a property or method
can cause a TypeError.

In other words, undefined to represent a system-level, unexpected, or error-
like absence of value and null to represent program-level, normal, or expected
absence of value.
*** The Global Object
    :PROPERTIES:
    :CUSTOM_ID: theGlobalObject
    :END:
The /global object/ is a regular JavaScript object that serves a very important
purpose: the properties of this object are the globally defined symbols that are
available to a JavaScript program. When the JavaScript interpreter starts (or
whenever a web browser loads a new page), it creates a /new/ global object and
give it an initial set of properties that define.

The initial properties of the global object are not reserved words, but they
deserve to be treated as if they are.

In top-level code, you can use the JavaScript keyword *this* to refer to the
global objects.

When first created, the global object defines all of JavaScript's predefined
global values.
*** Wrapper Objects
    :PROPERTIES:
    :CUSTOM_ID: wrapperObjects
    :END:
The temporary objects created when you access a property of a string, number, or
boolean are known as /wrapper objects/. Once the property has been resolved, the
newly created object is discarded. There are not wrapper objects for the null
and undefined values.

JavaScript converts wrapper objects into the wrapped primitive value as
necessary, so the wrapper objects usually, but not always, behave just like the
primitive values. The == equality operator treats a value and its wrapper object
as equal, but you can distinguish them with the === strict equality operator.
The typeof operator also can distinguish them.
*** Immutable Primitive Values and Mutable Object References
    :PROPERTIES:
    :CUSTOM_ID: immutablePrimitiveValuesAndMutableObjectReferences
    :END:
Primitives are immutable: there is no way to change a primitive value. Primitive
are also compared by value: two values are the same only if they have the same
value. Strings are equal if and only if they have the same length and if the
character at each index is the same.

Objects are mutable: their values can change. Objects are sometimes called
/reference types/ to distinguish them from JavaScript's primitive types. Objects
are compared by /reference/: two object values are the same if and only if they
/refer/ to the same underlying object. Assigning an object or array to a
variable simply assigns the reference: it does not create a new copy of the
object. If you want to make a new copy of an object or array, you must
explicitly copy the properties of the object or the elements of the array.
*** Type Conversion
    :PROPERTIES:
    :CUSTOM_ID: typeConversion
    :END:
JavaScript is very /flexible/ about the types of values it requires. The
primitive-to-primitive conversions are relatively straightforward.

Conversion to strings is well-defined for all primitive values.

Conversion to numbers is just a little trickier. Strings can be parsed as number
convert to those numbers. Leading and trailing spaces are allowed. Any
characters are not part of a numeric literal cause the string-to-number
conversion to produce *NaN*. Some numeric conversion are surprising: true
converts to 1, and false and  the empty string "" convert to 0, null converts to
0, undefined converts to NaN.
**** Conversions and Equality
The strict equality operator === that does not perform conversions when testing
for equality. == operator never attempts to convert its operands to booleans.
**** Explicit Conversions
Although JavaScript performs many type conversions automatically, you may
sometimes need to perform an explicit conversion. The simplest way to perform an
explicit type conversion is to use the =Boolean()=, =Number()=, =String()=
functions.

Any value other than null or undefined has a =toString()= method and the result
of this method is usually the same as that returned by the =String()= function.
Caution: Object(3) => new Number(3), does not throw an exception. Instead, it
simply returns a newly created empty object.

Formatting and parsing numbers are common tasks in computer programs and
JavaScript has specialized functions and methods that provide more precise
control over number-to-string and string-to-number conversions.

The =toString()= method defined by the Number class accepts an optional argument
that specifies a radix, or base, for the conversion (base 10 for default).

When working with financial or scientific data, you may want convert numbers to
strings in ways that give you control over the number of decimal places or the
number of significant digits in the output. The Number class defines three
methods for these kinds of number-to-string conversions.
- =toFixed()= :: converts a number to string with a specified number of digits
                 after the decimal point. It never uses exponential notation.
- =toExponential()= :: converts a number to string using exponential notation,
     with one digit before the decimal point and a specified number of digits
     after the decimal point.
- =toPrecision()= :: converts a number to string with the number of significant
     digits you specify. It uses exponential notation if the number of
     significant digits is not large enough to display the entire integer
     portion of the number.
All three methods /round/ the trailing digits or /pad with zeros/ as
appropriate.

If you pass a string to the =Number()= conversion function, it attempts to parse
that string as an integer or floating-point literal. ONLY works for base-10
integers and does not allow trailing characters that are not part of the
literal.
The =parseInt()= and =parseFloat()= are global functions, not method of any
class. =parseInt()= parses only integers. =parseFloat()= parses both integers
and floating-point numbers. Both =parseInt()= and =parseFloat()= skip leading
white-space, parse as many numeric characters as they can. If the first non-space
character is not part of a valid numeric literal, they return NaN.
=parseInt()= accepts an optional second argument specifying the radix (legal
value between 2 and 36) of the number to be parsed.
**** Object to Primitive Conversion
- Object-to-boolean conversion :: all objects converts to true, including
     wrapper objects.
- Object-to-string conversion :: only to native objects. Performed by invoking
     a method of the object to be converted.
- Object-to-number :: only to native objects. Performed by invoking
     a method of the object to be converted.

All objects inherit two conversion methods.

The first is called =toString()=, and its job is to return a string
representation of the object. The default =toString()= method does not return a
very interesting value. For example,
#+begin_src javascript
  ({x:1, y:2}).toString()         // => "[object object]"
#+end_src
Many classes define more specific version of the =toString()= method.
The =toString()= method of the /Array/ class converts each array element to a
string and joins the resulting strings together with commas in between.
The =toString()= method of the /Function/ class returns an
implementation-defined representation of a function. In practice, convert user-
defined functions to strings of JavaScript source code.
The =toString()= method of the /Date/ class returns a human-readable date and
time string.
The =toString()= method of the /RegExp/ class returns a string that looks like
a RegExp literal.

The other object conversion function is called =valueOf()=. The job of the
method is less well-defined. Objects are compound values, and most object cannot
really be represented by a single primitive value.
The /Wrapper/ classes define =valueOf()= methods that return the wrapped
primitive value.
Arrays, functions, and regular expressions simply inherit the default method.
Calling =valueOf()= for instances of these types simply returns the object
itself.
The /Date/ class defines a =valueOf()= method that returns the date in its
internal representation: the number of milliseconds since Jan. 1, 1970.

The rules on converting an object to a string:
+ If the object has a =toString()= method, JavaScript calls it. If it returns a
  primitive value, JavaScript converts that value to a string (if it is not
  already a string) and returns the result of that conversion.
+ If the object has no =toString()= method, or if that method does not return a
  primitive value, then JavaScript looks for a =valueOf()= method. If the method
  exists, JavaScript calls it. If the return value is a primitive, JavaScript
  converts that value to a string (if it is not already) and return the
  converted value.
+ Otherwise, JavaScript cannot obtain a primitive value from either =toString()=
  or =valueOf()=, so it throws a TypeError.

The rules on converting an object to a number: (does the same thing, but try
the =valueOf()= method first):
+ If the object has a =valueOf()= method that returns a primitive value,
  JavaScript converts that primitive value to a number and returns the result.
+ Otherwise, if the object has a =toString()= method that returns a primitive
  value, JavaScript converts and returns the value.
+ Otherwise, JavaScript throws a TypeError.

The object-to-primitive conversion used by + and == operator includes a special
case for Date objects. The Date class is the only predefined core JavaScript
type that define meaningful conversions to both strings and numbers. The
object-to-primitive conversion is basically an object-to-number conversion for
all objects that are not dates, and an object-to-string conversion for Date
objects. The primitive value returned by =valueOf()= or =toString()= is used
directly without being forced to a number or string.
The < operator and the other relational operators perform object-to-primitive
conversions like == does, but without the special case for Date objects: any
object is converted by trying =valueOf()= first and then =toString()=. Whatever
primitive value is obtained is used directly.

*Conclusion*: +, ==, != and the relational operators are the only ones that
perform this special kind of string-to-primitive conversions. Other operators
convert more explicitly to a specified type and do not have any special case
for Date objects. For examples:
#+begin_src javascript
  var now = new Date;
  typeof(now + 1)                 // "string": + converts dates to strings
  typeof(now - 1)                 // "number": - converts dates to numbers
  now == now.toString()           // true: implicit and explicit string conversions
  now > (now - 1)                 // true: converts a Date to a number
#+end_src
*** Variable Declaration
    :PROPERTIES:
    :CUSTOM_ID: variableDeclaration
    :END:
Before you use a variable in a JavaScript program, you should /declare/ it with
keyword /var/. You can write codes like these:
#+begin_src javascript
  var i;                          // declare a variable i, but not undefined
  var sum;
  var i, sum;                     // 3 methods for declaring variables, the same thing
  var message = "hello";
  var i = 0, j = 0, k = 0;        // always right
  for(var i = 0; i < 10; i++) console.log(i);
  for(var p in o) console.log(p); // var statement can also appear as part of the for and for/in loops
#+end_src
If you assign a value to an undeclared variable, JavaScript actually creates
that variable as a property of the global object. (Bad habit and a source of
bug)
*** Variable Scope
    :PROPERTIES:
    :CUSTOM_ID: variableScope
    :END:
The /scope/ of a variable is the region of your program source code in which it
is defined.
A /global/ variable has global scope, the /local/ variable has local scope.
Function parameters also count as local variables and are defined only within
the body of the function. You /must/ always use var to declare local variables.
JavaScript uses *function* scope, it means that all variables declared within a
function are visible /throughout/ the body of the function. Curiously, this
means that variables are even visible before they are declared.

In programming languages with block scope, it is generally good programming
practice to declare variables as close as possible to where they are used and
with the narrowest possible scope. JavaScript is a function scope programming
language, it is a good habit to declare all variables at the top of the function
which accurately reflect the true scope of the variables.

When you declare a global JavaScript variable, what you are actually doing is
defining a property of the global object. If you use var to declare the variable
, the property that is created is /nonconfigurable/, which means it cannot be
deleted with the delete operator. For example,
#+begin_src javascript
  var truevar = 1;  // a properly declared global variable, nondeletable
  fakevar = 2;      // creates a deletable property of the global object
  this.fakevar2 = 1;              // this does the same thing
  delete truevar;                 // => false
  delete fakevar;                 // => true
  delete this.fakevar2;           // => true
#+end_src
Every chunk of JavaScript code (global code or functions) has a /scope chain/
associated with it. This scope chain is a list or chain of objects that defines
the variables that are "in scope" for that code.

In top-level JavaScript code, the scope chain consists of a single object, the
global object. In a non-nested function, the scope chain consists of two objects
(The first is the object that defines the function's parameters and local
variables, and the second is the global object). In a nested function, the scope
chain has three or more objects.
When a function is defined, it stores the scope chain then in effect. When that
function is invoked, it creates a /new/ object to store its local variables, and
adds that new object to the stored scope chain to create a new, longer, chain
that represents the scope for that function invocation. This becomes more
interesting for nested functions because each time the outer function is called,
the inner function is defined again. Since the scope chain differs on each
invocation of the outer function, the inner function will be subtly different
each time it is defined.

Two great article on execution context and scope chain. [From David Shariff]
Links:
[[http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/][What is the Execution Context & Stack in JavaScript?]]
[[http://davidshariff.com/blog/javascript-scope-chain-and-closures/][Identifier Resolution and Closures in the JavaScript Scope Chain]]
** Expressions and Operators
   :PROPERTIES:
   :CUSTOM_ID: expressionsAndOperators
   :END:
*** Property Access Expressions
    :PROPERTIES:
    :CUSTOM_ID: propertyAccessExpressions
    :END:
A property access expression evaluates to the value of an object property or an
array element. JavaScript defines two syntaxes for property access:
=expression.identifier= or =expression[expression]= With either type of property
access expression, the expression before the . or [ is first evaluated. If the
value is null or undefined, the expression throws a TypeError.

The .identifier syntax is the simpler of the two property access options, but
notice that it can only be used when the property you want to access has a name
that is *a legal identifier*, and when you know the name when you write code. If
the property name is /a reserved word/ or /includes spaces or punctuation
characters/, or when it is /a number/, you must use the square bracket notation.
Square brackets are also used when the property name is /not static/ but is
itself the result of a computation.
*** Invocation Expressions
    :PROPERTIES:
    :CUSTOM_ID: invocationExpressions
    :END:
An /invocation expression/ JavaScript's syntax for calling a function or method.
When an invocation expression is evaluated, the function expression is evaluated
first, and then the argument expressions are evaluated to produce a list of
argument values. If the value of the function expression is not a callable
object, a TypeError is thrown. If the function uses a return statement to return
a value, then that value becomes the value of the invocation expression.
Otherwise, the value of the invocation expression is *undefined*.
Every invocation expression includes a pair of parentheses and an expression
before the open parenthesis. If that expression is a property access expression,
then the invocation is known as a /method invocation/. In method invocation, the
object or array that is the subject of the property access becomes the value of
the /this/ parameter while the body of the function is being executed.
Invocation expressions that are not method invocations normally use the global
object as the value of the this keyword.
*** Operator Overview
    :PROPERTIES:
    :CUSTOM_ID: operatorOverview
    :END:
Note that most operators are represented by punctuation characters. Some,
however, are represented by keywords such as /delete/ and /instanceof/. Keywords
operators are regular operators.
**** Number of Operands
Operators can be categorized based on the number of operands they expect. Most
JavaScript operators are /binary operators/. JavaScript also supports a number
of /unary operators/. Finally, it supports one /ternary operator/, the
conditional operator =? :=, which combines three expressions into a single
expression.
**** Operand and Result Type
Some operators work on values of any type, but most expect their operands to be
of a specific type, and most operators return a value of a specific type.

JavaScript operators usually convert the type of their operands as needed.
Remember also that every JavaScript value is either "truthy" or "falsy", so
operators that expect boolean operands will work with an operand of any type.

Some operators behave differently depending on the type of the operands used
with them.
**** Operator Side Effects
Some operands like (=, ++, --, delete) have /side effect/. No other JavaScript
operators have side effects, but function invocation and object creation
expressions will have side effects if any of the operators used in the function
or constructor body have side effects.
**** Order of Evaluation
Operator precedence and associativity specify the order in which operations are
performed in a complex expression, but they do not specify the order in which
the sub-expressions are evaluated.
*** Arithmetic Expressions
    :PROPERTIES:
    :CUSTOM_ID: arithmeticExpressions
    :END:
The basic arithmetic operators are (*, /, %, +, -). They evaluate their operands
, convert the values to numbers if necessary. Non-numeric operands that cannot
convert to numbers convert to the NaN value. If either operand is NaN, the
result of the operation is also NaN.
In JavaScript, all numbers are floating-point. Division by zero yields positive
or negative infinity, while 0/0 evaluates to NaN: neither of these cases raises
an error.
The sign of the result of the % operator is the same as the sign of the first
operand.
**** The + Operator
If either of the operands is a string or an object that converts to a string,
the other operand is converted to a string and concatenation is performed.
Addition is performed only if neither operand is string-like.
*Caution*: null -> number  // => 0; undefined -> number // => NaN
It is important to note that when the + operator is used with strings and
numbers, it may not be associative. That is, the result may depend on the order
in which operations are performed. For example,
#+begin_src javascript
  1 + 2 + " blind mice"           // => "3 blind mice"
  1 + (2 + " blind mice")         // => "12 blind mice"
#+end_src
**** Unary Arithmetic Operators
In JavaScript, the unary operators all have high precedence and are all right-
associative. The arithmetic unary operators convert their single operand to a
number, if necessary. Increment operators (both ++ and --) have lvalue operand.
Note that the expression ++x is not always the same as x = x + 1.
*** Relational Expressions
    :PROPERTIES:
    :CUSTOM_ID: relationalExpressions
    :END:
The == operator checks whether its two operands are equal, allowing type
conversion.
The strict equality === operator evaluates its operands, and then compare the
two values as follows, performing no type conversion.
Conclusion: Both the + operator and the comparison operators behave differently
for numeric and string operands. + favors strings: it performs concatenation if
either operand is a string. The comparison operators favor numbers and only
perform string comparison if both operands are strings.
**** The in Operator
The /in/ operator expects a left-hand operand that is or can be converted to a
string. It expects a right-hand operand that is an object. It evaluates to true
if the left-hand value is the name of a property of the right-hand object.
**** The instanceof Operator
The /instanceof/ operator expects a left-hand operand that is an object and a
right-hand operand that identifies a class of objects. The operator evaluates to
true if the left-hand object is an instance of the right-hand class.
If the left-hand operand of /instanceof/ is not an object, /instanceof/ returns
false. If the right-hand side is not a function, it throws a TypeError.
*** Logical Expressions
    :PROPERTIES:
    :CUSTOM_ID: logicalExpressions
    :END:
**** Logical And (&&)
The && operator can be understood at three different levels.
1. when used with boolean operands, it returns true if and only if both its
   operand and its second operand are true.
2. && does not require that its operands be boolean values. The && operator can
   understand truthy and falsy values. If both operands are truthy, the operator
   returns a truthy value, otherwise, a falsy value.
3. This operator starts by evaluating its first operand, the expression on its
   left. If the value on the left is falsy, so && simply returns the value on
   the left and does not even evaluate the expression on the right. If the value
   on the left is truthy, then the overall value of the expression depends on
   the value on the right-hand side.

In general, you must be careful whenever you write an expression with side
effects on the right-hand side of &&. Whether those side effects occur depends
on the value of the left-hand side.
**** Logical Or (||)
Like && operator. It starts by evaluating its first operand, the expression on
its left. If the value of this first operand is truthy, it returns that truthy
value. Otherwise, it evaluates its second operand, the expression on its right,
and returns the value of that expression.
**** Logical NOT (!)
Unlike the && and || operators, the ! operator converts its operand to a boolean
value before inverting the converted value. This means that ! always returns
true or false, and you can convert any value x to its equivalent boolean value
by applying this operator twice: !!x
**** The delete Operator
/delete/ is an unary operator that attempts to delete the object property or
array element specified as its operand. Deleting an array element leaves a
"hole" in the array and does not change the array's length. The resulting array
is sparse.
/delete/ expects its operand to be an lvalue. If it is not an lvalue, the
operator takes no action and returns true. Not all properties can be deleted.
Some built-in core and client-side properties are immune from deletion, and user
-defined variables declared with the var statement cannot be deleted. Functions
defined with the function statement and declared function parameters can not be
deleted either.

In ECMAScript 5 strict mode, /delete/ raises a SyntaxError if its operand is an
unqualified identifier. Also specifies that /delete/ raises a syntaxError if
asked to delete any nonconfigurable property.
** Statements
   :PROPERTIES:
   :CUSTOM_ID: statements
   :END:
Expressions are evaluated to produce a value, but statements are executed to
make something happen (create side effects).
*** Declaration Statements
    :PROPERTIES:
    :CUSTOM_ID: declarationStatements
    :END:
**** function
#+begin_src javascript
  var f = function(x) { return x+1; }; // Expression assigned to a variable
  function f(x) { return x+1; }        // Statement includes variable name
#+end_src
Function declaration statements may appear in top-level JavaScript code, or they
may be nested within other functions. When nested, however, function
declarations only appear at the top level of the function they are nested
within.
Function declaration statements diff from function definition expressions in
that they include a function name. Both forms create a new function objects,
but the function declaration statement also declares the function name as a
variable and assigns the function object to it. Like variables declared with
/var/, function defined with function definition statements are implicitly
"hoisted" to the top of the containing script or function, so that they are
visible throughout the script or function. With /var/, *only* the variable
declaration is hoisted - the variable initialization code *remains* where you
place it. This means that you can invoke a JavaScript function before you
declare it.
*** Conditionals
    :PROPERTIES:
    :CUSTOM_ID: conditionals
    :END:
**** switch
ECMAScript standard allows each /case/ to be followed by an arbitrary
/expression/. The /switch/ statement first evaluates the expression that follows
the /switch/ keyword and then evaluates the /case/ expressions, in the order in
which they appear, until it finds a value that matches (use strict compare).
Because not all of the /case/ expressions are evaluated each time the /switch/
statement is executed, you should avoid using /case/ expressions that contain
side effects. The safest course is simply to limit your /case/ expressions to
constant expressions.
*** Loops
    :PROPERTIES:
    :CUSTOM_ID: loops
    :END:
**** do/while
The do/while loop is executed at least once, and requires both do keyword and
the while keyword. Also, the do loop must always be terminated with a semicolon.
**** for/in
A for/in loop looks like this:
#+begin_src javascript
  for (variable in object)
    statement
#+end_src
/variable/ must be a lvalue, /object/ is an expression that evaluates to an
object.
To execute a for/in statement, the JavaScript interpreter first evaluates the
object expression. If it evaluates to null or undefined, the interpreter skips
the loop and moves to the next statements. If it evaluates to a primitive value,
that value is converted to its equivalent wrapper object. Otherwise, an object.
The interpreter now executes the body of the loop once for each enumerable
property of the object. Before each iteration, however, the interpreter
evaluates the variable expression and assigns the name of the property to it.

The for/in loop does not actually enumerate all properties of an object, only
the /enumerable/ properties. The various built-in methods defined by core
JavaScript are not enumerable. In addition to built-in methods, many other
properties of the built-in objects are non-enumerable. All properties and method
defined by your code are enumerable.
*** Jumps
    :PROPERTIES:
    :CUSTOM_ID: jumps
    :END:
The /break/ statement makes the interpreter jump to the end of a loop or other
statement. /continue/ makes the interpreter skip the rest of the body of a loop
and jump back to the top of a loop to begin a new iteration.
JavaScript allows statements to be named, or labeled, and the break and continue
can identify the target loop or other statement label.

The /return/ statement makes the interpreter jump from a function invocation
back to the code invoked it and also supplies the value for the invocation. The
/throw/ statement raises, or "throws," an exception and is designed to work with
the try catch finally statement.
**** Labeled Statements
It is only useful to label statements that have bodies, such as loops and
conditionals. /break/ and /continue/ are the only JavaScript statements that use
statement labels. You can use the same identifier as a statement label and as a
variable or function name. A statement may not have the same label as a
statement that contains it. Any statement may have multiple labels.
**** break
The /break/ statement causes the innermost enclosing loop or switch statement to
exit immediately. This form of the /break/ statement is legal only if it appears
inside one of these statements.

When you want to break out of a statement that is not the nearest enclosing loop
or a switch you need the labeled form of the /break/ statement. You cannot label
a function definition statement.
**** continue
Similar to the break statement, in both its labeled and unlabeled forms, can be
used only within the body of a loop.
**** return
A return statement may appear only within the body of a function. A function
returns to its caller when a return statement is executed, even if there are
other statements remaining in the function body. If there is no return
statement, /undefined/ is returned.
**** throw
To throw an exception is to signal an error or exceptional condition when some
sort of exceptional condition or error has occurred.
The /throw/ statement has the following syntax:
#+begin_src javascript
  throw expression;               // throw statement
#+end_src
expression may evaluate to a value of any type. You might throw a number that
represents an error code or a string that contains a human-readable error
message. The Error class and its subclasses are also used when the JavaScript
interpreter itself throws an error.
**** try catch finally
The try catch finally statement is JavaScript's exception handling mechanism.
The following code illustrates the syntax and purpose of the try catch finally
statement:
#+begin_src javascript
  try {
    // Normally, this code runs from the top of the block to the bottom
    // without problems. But it can sometimes throw an exception,
    // either directly, with a throw statement, or indirectly, by calling
    // a method that throws an exception.
    }
  catch (e) {
    // The statements in this block are executed if, and only if, the try
    // block throws an exception. These statements can use the local variable
    // to refer to the Error object or other value that was thrown.
    // This block may handle the exception somehow, may ignore the
    // exception by doing nothing, or may rethrow the exception with throw.
    }
  finally {
    // This block contains statements that are always executed, regardless of
    // what happens in the try block. They are executed whether the try block
    // terminates:
    // 1) normally, after reaching the bottom of the block
    // 2) because of a break, continue, or return statement
    // 3) with an exception that is handled by a catch clause above
    // 4) with an uncaught exception that is still propagating
    }
#+end_src
The /catch/ keyword is followed by an identifier in parentheses. This identifier
is like a function parameter. When an exception is caught, the value associated
with the exception (an Error object, for example) is assigned to this parameter.
Unlike regular variables, the identifier associated with a /catch/ clause has
*block scope* - it is only defined within the /catch/ block.

The /finally/ clause is guaranteed to be executed if any portion of the /try/
block is executed, regardless of how the code in the /try/ block completes. It
is generally used to clean up after the code in the /try/ clause.
*The rules of /finally/ execution order*:
In the normal case, the JavaScript interpreter reaches the end of the /try/
block and then proceeds to the /finally/ block, which performs any necessary
cleanup. If the interpreter left the /try/ block because of a /return/,
/continue/, or /break/ statement, the /finally/ block is executed before the
interpreter jumps to its new destination.
If an exception occurs in the /try/ block and there is an associated /catch/
block to handle the exception, the interpreter first executes the /catch/ block
and then the /finally/ block. If there is no local /catch/ block to handle the
exception, the interpreter first executes the /finally/ block and then jumps to
the nearest containing /catch/ clause.
If a /finally/ block itself causes a jump with a /return/, /continue/, /break/,
or /throw/ statement, or by calling a method that throws an exception, the
interpreter abandons whatever jump was pending and performs the new jump.
*** Miscellaneous Statements
    :PROPERTIES:
    :CUSTOM_ID: miscellaneousStatements
    :END:
**** with
The /with/ statement is used to temporarily extend the scope chain. It has the
following syntax:
#+begin_src javascript
  with (object)
    statement
#+end_src
This statement adds /object/ to the front of the scope chain, executes
/statement/, and then restores the scope chain to its original state. The /with/
statement is forbidden in strict mode and should be deprecated. Please avoid
using it whenever possible.
The common use of the /with/ statement is to make it easier to work with deeply
nested object hierarchies. A /with/ statement provides a shortcut for reading
properties of o, but not for creating new properties of o. Keep in mind that the
scope chain is used only when looking up identifiers, not when creating new
ones.
**** debugger
In practice, the /debugger/ statement acts like a breakpoint: execution of
JavaScript code stops and you can use the debugger to print variables' values,
examine the call stack, and so on. For example:
#+begin_src javascript
  // When f() is called with no argument, execution will stop, and you
  // can use the debugger to inspect the call stack and find out where
  // this incorrect call is coming from.
  function f(o) {
    if (o === undefined) debugger;
    ...
    }
#+end_src
**** "use strict"
"use strict" is a /directive/ introduced in ECMAScript 5. Directives are not
statements. It can appear only at the start of a script or at the start of a
function body, before any real statements have appeared.
Strict code is executed in /strict mode/. The strict mode of ECMAScript 5 is
a restricted subset of the language that fixes a few important language
deficiencies and provides stronger error checking and increased security.
The three particularly important differences between strict mode and non-strict
mode are the following:
1. The /with/ statement is not allowed in strict mode
2. In strict mode, all variables must be declared
3. In strict mode, functions invoked as functions have a /this/ value of
   /undefined/. Can be used to determine whether an implementation supports
   strict mode:
#+begin_src javascript
  var hasStrictMode = (function() { "use strict"; return this === undefined }());
#+end_src
Other differences:
+ In strict mode, assignments to non-writable properties and attemps to create
  new properties on non-extensible objects throw a TypeError. (In non-strict
  mode, these attempts fail silently.)
+ In strict mode, code passed to =eval()= cannot declare variables or define
  functions in the caller's scope as it can in non-strict mode. Instead,
  variable and function definitions live in a new scope created for the =eval()=
  . This scope is discarded when the =eval()= returns.
+ In strict mode, the /arguments/ object in a function holds a static copy of
  the values passed to the function. In non-strict mode, the /arguments/ object
  has "magical" behavior in which elements of the array and named function
  parameters both refer to the same value.
+ In strict mode, a SyntaxError is thrown if the /delete/ operator is followed
  by an unqualified identifier such as a variable, function, or function
  parameter.
+ In strict mode, an attempt to delete a non-configurable property throws a
  TypeError.
+ In strict mode, it is a syntax error for an object literal to define two or
  more properties by the same name and for a function declaration to have two or
  more parameters with the same name.
+ In strict mode, octal integer literals are not allowed.
+ In strict mode, the identifier /eval/ and /arguments/ are treated like
  keywords, and you are not allowed to change their value.
+ In strict mode, the ability to examine the call stack is restricted.
** Objects
   :PROPERTIES:
   :CUSTOM_ID: objects
   :END:
An object is an unordered collection of properties, each of which has a name and
a value. Property names are strings, so we can say that objects map strings to
values. An object is more than a simple string-to-value map. In addition to
maintaining its own set of properties, a JavaScript object also inherits the
properties of another object, known as its "prototype".

Objects are mutable and are manipulated by reference rather than by value. The
most common things to do with objects are create them and to set, query, delete,
test, and enumerate their properties.

A /property/ has a name and a value. A property name may be any string,
including the empty string, but no object may have two properties with the same
name. The value may be any JavaScript value, or (in ECMAScript 5) it may be a
getter or a setter function (or both). In addition to its name and value, each
property has associated values that are called /property attributes/:
1. The /writable/ attribute specifies whether the value of the property can be
   set.
2. The /enumerable/ attribute specifies whether the property name is returned by
   a =for/in= loop.
3. The /configurable/ attribute specifies whether the property can be deleted
   and whether its attributes can be altered.
Every object has three associated /object attributes/:
1. An object's /prototype/ is a reference to another object from which
   properties are inherited.
2. An object's /class/ is a string that categorizes the type of an object.
3. An object's /extensible/ flag specifies whether new properties may be added
   to the object.

Distinguish among three broad categories of JavaScript objects and two types of
properties:
+ A /native/ object is an object or class of objects defined by the ECMAScript 5
  specification. Arrays, functions, dates, and regular expressions are native
  objects.
+ A /host/ object is an object defined by the host environment within which the
  JavaScript interpreter is embedded.
+ A /user-defined/ object is any object created by the execution of JavaScript
  code.
+ An /own property/ is a property defined directly on an object.
+ An /inherited property/ is a property defined by an object's prototype object.
*** Creating Objects
    :PROPERTIES:
    :CUSTOM_ID: creatingObjects
    :END:
**** Object Literals
An /object literal/ is a commoa-separated list of colon-separated name:value
pairs, enclosed within curly braces.
In ECMAScript 5, reserved words may be used as property names without quoting
except ECMAScript 3. Trailing commas are ignored in most ECMAScript 3
implementations, but IE considers them an error.
*NOTE* An object literal is an expression that creates and initializes a new and
distinct object each time it is evaluated.
**** Creating Objects with new
The *new* operator creates and initializes a new object. The *new* keyword must
be followed by a function (called /constructor/) invocation.
**** Prototypes
Every JavaScript object has a second JavaScript object (or *null*, but this is
rare) associated with it. This second object is known as a prototype, and the
first object inherits properties from the prototype. All objects created by
object literals have the same prototype object - *Object.prototype*. Objects
created using the *new* keyword and a constructor invocation use the value of
the *prototype* property of the constructor function as their prototype.
*Object.prototype* is one of the rare objects that has no prototype: it does not
inherit any properties. Linked series of prototype objects is known as a
/prototype chain/.
**** Object.create()
ECMAScript 5 defines a method, =Object.create()=, that creates a new object,
using its first argument as the prototype of that object. =Object.create()= also
takes an optional second argument that describes the properties of the new
object. If you want to create an ordinary empty object, pass *Object.prototype*:
#+begin_src javascript
  var o3 = Object.create(Object.prototype); // o3 is like {} or new Object{}
#+end_src
*** Querying and Setting Properties
    :PROPERTIES:
    :CUSTOM_ID: queryingAndSettingProperties
    :END:
**** Objects As Associative Arrays
When you use the dot operator to access a property of an object, identifiers
must be typed literally into your JavaScript program. They are not a datatype,
so they cannot be manipulated by the program.
When you use the [] array notation, the name of the property is expressed as a
string. Strings are JavaScript datatypes, so they can be manipulated and created
while a program is running. For example:
#+begin_src javascript
  var addr = "";
  for(var i = 0; i < 4; i++) {
    addr += customer["address" + i] + '\n';
  }
#+end_src
Use the [] operator, because it uses a string value (which is dynamic and can
change at run-time) rather than an identifier (which is static and must be
hardcoded in the program) to name the property.
#+begin_src javascript
  function getValue(portfolio) {
    var total = 0.0;
    for (stock in portfolio) {
      var shares = portfolio[stock];
      var price = getQuote[stock];
      total += shares * price;
    }
    return total;
  }
#+end_src
**** Inheritance
If the assignment is allowed, however, it always creates or sets a property in
the original object and never modifies the prototype chain. The fact that
inheritance occurs when querying properties but not when setting them is a key
feature of JavaScript because it allows us to selectively override inherited
properties.
#+begin_src javascript
  var unitcircle = { r:1 };       // an object to inherit from
  var c = inherit(unitcircle);    // c inherits the property r
  c.x = 1; c.y = 1;               // c defines two properties of its own
  c.r = 2;                        // c overrides its inherited property
  unitcircle.r;                   // => 1: the prototype object is not affected
#+end_src
There is one exception to the rule that a property assignment either fails or
creates or sets a property in the original object. If o inherits the property x,
and that property is an accessor property with a setter method, then that setter
method is called rather than creating a new property x in o.
**** Property Access Errors
It is not an error to query a property that does not exist, but attempting to
query a property of an object that does not exist is an error. Curiously,
however, some failed attempts to set properties usually fail silently. In strict
mode, any failed attempt to set a property throws a TypeError exception.
The rules that specify when a property assignment succeeds and when it fails. An
attempt to set a property p of an object o fails in these circumstances:

+ o has an own property p that is read-only (for an exception that allows
configurable read-only properties to be set).
+ o has an inherited property p that is read-only.
+ o does not have an own property p; o does not inherit a property p with a
  setter method, and o's *extensible* attribute is *false*. If p does not
  already exist on o, and if there is no setter method to call, then p must be
  added to o. But if o is not extensible, then no new properties can be defined
  on it.
**** Deleting Properties
     :PROPERTIES:
     :CUSTOM_ID: deletingProperties
     :END:
The *delete* operator's single operand should be a property access expression.
*delete* does not operate on the value of the property but on the property
itself. The *delete* operator only deletes own properties, not inherited ones.
A *delete* expression evaluates to *true* if the delete succeeded or if the
delete had no effect or when used with an expression that is not a property
access expression. *delete* does not remove properties that have a
/configurable/ attribute of *false*.
When deleting configurable properties of the global object in strict mode, you
must include the reference to the global object and simply follow the *delete*
operator with the property name.
#+begin_src javascript
  this.x = 1;                     // create a configurable global property
  delete x;                       // syntaxError in strict mode
  delete this.x;                  // this works
#+end_src
*** Testing Properties
    :PROPERTIES:
    :CUSTOM_ID: testingProperties
    :END:
To check whether an object has a property with a given name.
The *in* operator expects a property name on its left side and an object on its
right. It returns *true* if the object has an own property or an inherited
property by that name.
The =hasOwnProperty()= method of an object tests whether that object has an own
property with the given name. It returns *false* for inherited properties.
The =propertyIsEnumerable()= returns *true* only if the named property is an own
property and its *enumerable* attribute is *true*.
*** Enumerating Properties
    :PROPERTIES:
    :CUSTOM_ID: enumeratingProperties
    :END:
Use =for/in= loop obtaining a list of all enumerable properties of an object.
In addition to the =for/in= loop, ECMAScript 5 defines two function that
enumerate property names.
1. =Object.keys()= returns an array of the names of the enumerable own
   properties of an object.
2. =Object.getOwnPropertyNames()= returns the names of all the own properties of
   the specified object.
*** Property Getters and Setters
    :PROPERTIES:
    :CUSTOM_ID: propertyGettersAndSetters
    :END:
Object property is a name, a value, and a set of attributes. In ECMAScript 5,
the value may be replaced by one or two methods, known as a /getter/ and
/setter/. They are sometimes known as /accessor properties/ to distinguish them
from /data properties/ that have a simple value. Accessor properties do not have
a /writable/ attributes as data properties do. If a property has both a getter
and a setter method, it is a read/write property.
The easiest way to define accessor properties is with an extension to the object
literal syntax:
#+begin_src javascript
  var o = {
    // an ordinary data property
    data_prop: value,

    // an accessor property defined as a pair of functions
    get accessor_prop() {/* function body here */},
    set accessor_prop() {/* function body here */}
  };
#+end_src
*** Property Attributes
    :PROPERTIES:
    :CUSTOM_ID: propertyAttributes
    :END:
The ECMAScript 5 API for querying and setting property attributes is
particularly important to library authors because:
+ It allows them to add methods to prototype objects and make them nonenumerable
  , like built-in methods
+ It allows them to "lock down" their objects, defining properties that cannot
  be changed or deleted

The four attributes of a /data property/ are value, writable, enumerable, and
configurable; and /accessor property/ are get, set, enumerable, configurable.
The ECMAScript 5 methods for querying and setting the attributes of a property
use an object called a /property descriptor/ to represent the set of four
attributes. The property descriptor object of a data property has properties
named *value*, *writable*, *enumerable*, *configurable*. And the descriptor for
an accessor property has *get* and *set* properties instead of *value* and
*writable*. The writable, enumerable, configurable are boolean values, and the
get and set properties are function values.

To obtain the property descriptor for a named property of a specified object,
call =Object.getOwnPropertyDescriptor()=, only for own properties. To query the
attributes of inherited properties, use =Object.getPrototypeOf()= instead.

To set the attributes of a property, or to create a new property with the
specified attributes, call =Object.defineProperty()=, passing the object to be
modified, the name of the property to be created or altered, and the property
descriptor object. The property descriptor passed to =Object.defineProperty()=
does not have to include all four attributes. If you're creating a new property
, then omitted attributes are taken to be *false* or *undefined*. If you're
modifying an existing property, then the attributes you omit are simply left
unchanged. Note that this method alters an existing own property or creates a
new own property, but it will not alter an inherited property. If you want
modify more than one property at a time, use =Object.defineProperties()= instead
. The first argument is the object that is to be modified. The second argument
is an object that maps the names of the properties to be created or modified to
the property descriptors for those properties.

The complete rules for =Object.defineProperty()= or =Object.defineProperties()=
should be followed, otherwise, throw TypeError.
1. If an object is not extensible, you can edit its existing own properties, but
   you cannot add new properties to it.
2. If a property is not configurable, you cannot change its configurable or
   enumerable attributes.
3. If an accessor property is not configurable, you cannot change its getter or
   setter method, and you cannot change it to a data property.
4. If a data property is not configurable, you cannot change it to an accessor
   property.
5. If a data property is not configurable, you cannot change its /writable/
   attribute from *false* to *true*, but you can change it from *true* to
   *false*.
6. If a data property is not configurable and not writable, you cannot change
   its value. You can change the value of a property that is configurable but
   non-writable.
*** Object Attributes
    :PROPERTIES:
    :CUSTOM_ID: objectAttributes
    :END:
Every object has associated /prototype/, /class/, /extensible/ attributes.
**** The prototype Attribute
In ECMAScript 5, you can query the prototype of any object by passing that
object to =Object.getPrototypeOf()=. To determine whether one object is the
prototype of another object, use the =isPrototypeOf()= method.
**** The class Attribute
Use =classof()= to obtain object's class attribute.
**** The extensible Attribute
The /extensible/ attribute of an object specifies whether new properties can be
added to the object or not. To determine whether an object is extensible, pass
it to =Object.isExtensible()=. To make an object non-extensible, pass it to
=Object.preventExtensions()=. Note that there is no way to make an object
extensible again once you have made it non-extensible. Also note that calling
=Object.preventExtensions()= only affects the extensibility of the object itself
. If new properties are added to the prototype of a non-extensible object, the
non-extensible object will inherit those new properties.
The purpose of the /extensible/ attribute is to be able to "lock down" objects
into a known state and prevent outside tampering. The /extensible/ attribute is
often used in conjunction with the /configurable/ and /writable/ property
attributes. In ECMAScript 5, there are two functions that make it easy to set
these attributes together.
=Object.seal()= makes the object non-extensible, it also makes all of the own
properties of that object non-configurable. No way to unseal a sealed object
again. To determine whether an object is sealed using =Object.isSealed()=
method. =Object.freeze()= makes the object non-extensible and its properties
non-configurable, it also makes all of the object's own data properties (not
accessor properties) read-only. Use =Object.isFrozen()= to determine if an
object is frozen. They only affect the object they are passed, do not have
effect on prototype of that object.
*** Serializing Objects
    :PROPERTIES:
    :CUSTOM_ID: serializingObjects
    :END:
Object serialization is the process of converting an object's state to a string
from which it can later be restored. ECMAScript 5 provides native functions
=JSON.stringify()= and =JSON.parse()= to serialize and restore JavaScript
objects.
** Arrays
   :PROPERTIES:
   :CUSTOM_ID: arrays
   :END:
JavaScript arrays are /untyped/, /dynamic/, may be /sparse/ and every arrays
have a *length* property. Access to numerically indexed array elements is
generally significantly faster than access to regular object properties.

Arrays inherit properties from *Array.prototype*, which defines a rich set of
array manipulation methods. Most of these methods are /generic/, it means that
they work correctly not only for true arrays, but for any "array-like object".
*** Creating Arrays
    :PROPERTIES:
    :CUSTOM_ID: creatingArrays
    :END:
1. Create an array with an array literal, which is simply a comma-separated list
   of array elements within square brackets. The value in an array literal may
   be arbitrary expressions. Multiple commas in a row, with no value between is
   called *sparse array*. Array elements for which values are omitted do not
   exist, but appear to be *undefined* if you query them. Optional trailing
   comma is allowed.
2. Create an array with the =Array()= constructor.
   + Call with no argument
     #+begin_src javascript
       var a = new Array();
     #+end_src
   + Call with a single numeric argument
     #+begin_src javascript
       var a = new Array(10);          // Specify a length, no value and array index properties are defined.
     #+end_src
   + Explicitly specify two or more array elements or a single non-numeric
     element for the array
     #+begin_src javascript
       var a = new Array(5, 4, 3, "testing") // Using array literal is simpler than this
     #+end_src
*** Reading and Writing Array Elements
    :PROPERTIES:
    :CUSTOM_ID: readingAndWritingArrayElements
    :END:
What is special about arrays is that when you use property names that are
non-negative integers less than 2^32, the array /automatically/ maintains the
value of the length property.

Note that if you index an array using numbers that are negative or that are not
integers, the number is converted to a string, and that string is used as the
property name. If you index an array with a string that happens to be a
non-negative integer, it behaves as an array index, not an object property.
*** Sparse Arrays
    :PROPERTIES:
    :CUSTOM_ID: sparseArrays
    :END:
Sparse arrays can be created with the =Array()= constructor or simply by
assigning to an array index larger than the current array *length*
#+begin_src javascript
  a = new Array(5);                // No elements, but a.length is 5
  a = [];                          // Create an array with no elements and length = 0
  a[1000] = 0;                     // Assignment adds one element but sets length to 1001
#+end_src
*** Array Length
    :PROPERTIES:
    :CUSTOM_ID: arrayLength
    :END:
An array (sparse or not) will never have an element whose index is greater than
or equal to its *length*. In order to maintain this invariant, arrays have two
special behaviors. The first: if you assign a value to an array element whose
index i is greater than or equal to the array's current length, the value of the
length property is set to i+1. The second: if you set the length property to a
non-negative integer n smaller than its current value, any array elements whose
index is greater than or equal to n are deleted from the array.
*** Adding and Deleting Array Elements
    :PROPERTIES:
    :CUSTOM_ID: addingAndDeletingArrayElements
    :END:
=push()= method to add one or more values to the end of an array.
=unshift()= method to insert a value at the beginning of an array, shifting the
existing array elements to higher indexes.
=delete= operator deletes array element, assigning *undefined* to deleted
element. Note that using =delete= on an array element does not alter the
*length* property and does not shift elements with higher indexes down to fill
in the gap that is left by the deleted property.
*** Iterating Arrays
    :PROPERTIES:
    :CUSTOM_ID: iteratingArrays
    :END:
The ECMAScript specification allows the =for/in= loop to iterate the properties
of an object in any order (a =for/in= loop can return the names of inherited
properties). ECMAScript 5 defines a number of new methods for iterating array
elements by passing each one, in index order, to a function that you define. The
=forEach()= method is the most general of these methods.
*** Multidimensional Arrays
    :PROPERTIES:
    :CUSTOM_ID: multidimensionalArrays
    :END:
JavaScript does not support true multidimensional arrays, but you can
approximate them with arrays of arrays.
*** Array Methods
    :PROPERTIES:
    :CUSTOM_ID: arrayMethods
    :END:
=Array.join()= method converts all the elements of an array to strings and
concatenates them, returning the resulting string. An optional string separates
the elements in the resulting string. If no separator string is specified, a
comma is used.
=Array.reverse()= method reverses the order of the elements of an array and
returns the reversed array.
=Array.sort()= method sorts the elements of an array in place and returns the
sorted array. When it is called with no arguments, it sorts the array elements
in alphabetical order. If an array contains undefined elements, they are sorted
to the end of the array. To sort an array into some order other than
alphabetical, you must pass a comparison function as an argument to
=Array.sort()=. This function decides which of its two arguments should appear
first in the sorted array.
=Array.concat()= method creates and returns a /new/ array that contains the
elements of the original followed by each of the arguments to =concat()=. Note
that it does not recursively flatten arrays of arrays.
=Array.slice()= method returns a slice, or subarray, of the specified array. Its
two arguments specify the start and end (not including) of the slice to be
returned. =slice()= does not modify the array on which it is invoked.
=Array.splice()= method is a general-purpose method for inserting or removing
elements from an array. The first arguments to =splice()= specifies the array
position at which the insertion and/or deletion is to begin. The second
argument specifies the number of elements that should be deleted from the array.
If the second argument is omitted, all array elements from the start element to
the end of the array are removed. It returns an array of the deleted elements.
The first two arguments to =splice()= specify which array elements are to be
deleted. These arguments may be followed by any number of additional arguments
that specify elements to be inserted into the array, starting at the position
specified by the first argument. For example,
#+begin_src javascript
  var a = [1, 2, 3, 4, 5, 6, 7, 8];
  a.splice(4);                    // Returns [5, 6, 7, 8], a is [1, 2, 3, 4]
  a.splice(1, 2);                 // Returns [2, 3], a is [1, 4]
  var b = [1, 2, 3, 4, 5];
  b.splice(2, 0, 'a', 'b');       // Returns []; b is [1, 2, 'a', 'b', 3, 4, 5]
  b.splice(2, 2, [1, 2], 3);      // Returns ['a', 'b'], b is [1, 2, [1, 2], 3, 3, 4, 5]
#+end_src
=push()= method appends one or more new elements to the end of an array and
returns the new length of the array.
=pop()= method deletes the last element of an array, decrements the array length
, and returns the value that it removed.
Both =unshift()= and =shift()= methods modify the array in place rather than
produce a modified copy of the array.
Both methods behave much like push and pop, except that they insert and remove
elements from the beginning of an array rather than from the end. Note that
arguments are inserted or deleted all at once.
*** ECMAScript 5 Array Methods
    :PROPERTIES:
    :CUSTOM_ID: ecmascript5ArrayMethods
    :END:
ECMAScript 5 defines nine new array methods for iterating, mapping, filtering,
testing, reducing, and searching arrays. First, most of the methods accept a
function as their first argument and invoke that function once for each element
of the array. If the array is sparse, the function you pass is not invoked for
non-existent elements. In most cases, the function you supply is invoked with
three arguments: the value of the array element, the index of the array element,
and the array itself. Most of the ECMAScript 5 array methods that accept a
function as their first argument accept an optional second argument. If
specified, the function is invoked as if it is a method of this second argument.
None of the ECMAScript 5 array methods modify the array on which they are
invoked.
**** forEach()
=forEach()= method iterates through an array, invoking a function you specify
for each element. Note that =forEach()= does not provide a way to terminate
iteration before all elements have been passed to the function. If you need to
terminate early, you must throw an exception, and place the call to =forEach()=
within a =try= block.
**** map()
=map()= method passes each element of the array on which it is invoked to the
function you specify, and returns an array containing the values returned by
that function. If the array is sparse, the returned array will be sparse in the
same way: it will have the same length and the same missing elements.
**** filter()
=filter()= method returns an array containing a subset of the elements of the
array on which it is invoked. Note that =filter()= skips missing elements in
sparse arrays, and that its return value is always dense.
**** every() and some()
=every()= method is like the mathematical "for all" quantifier \forall: it
returns true if and only if your predicate function returns true for all
elements in the array. Returns true when invoked on an empty array.
=some()= method is like the mathematical "there exists" quantifier \exist: it
returns true if there exists at least one element in the array for which the
predicate returns true, and returns false if and only if the predicate returns
false for all elements of the arrays. Returns false when invoked on an empty
array.
**** reduce() and reduceRight()
Both methods combine the elements of an array, using the function you specify,
to produce a single value.
**** indexOf() and lastIndexOf()
Search an array for an element with a specified value, and return the index of
the first/last such element found, or -1 if none is found.
*** Array Type
    :PROPERTIES:
    :CUSTOM_ID: arrayType
    :END:
In ECMAScript 5, =Array.isArray()= function is used to determine whether an
array is an array or not.
*** Array-like Objects
    :PROPERTIES:
    :CUSTOM_ID: arrayLikeObjects
    :END:
The JavaScript array methods are purposely defined to be generic, so that they
work correctly when applied to array-like objects in addition to true arrays.
Array-like objects do not inherit from =Array.prototype=, you cannot invoke
array methods on them directly.
*** Strings As Arrays
    :PROPERTIES:
    :CUSTOM_ID: stringsAsArrays
    :END:
Keep in mind that strings are immutable values, they are read-only arrays.
Attempting to modify a string using an array method does not, however, cause an
error: it simply fails silently.
